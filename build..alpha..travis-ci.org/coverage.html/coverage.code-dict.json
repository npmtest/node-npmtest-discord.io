{"/home/travis/build/npmtest/node-npmtest-discord.io/test.js":"/* istanbul instrument in package npmtest_discord_io */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-discord.io/lib.npmtest_discord.io.js":"/* istanbul instrument in package npmtest_discord_io */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_discord_io = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_discord_io = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-discord.io/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-discord.io && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_discord_io */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_discord_io\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_discord_io.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_discord_io.rollup.js'] =\n            local.assetsDict['/assets.npmtest_discord_io.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_discord_io.__dirname +\n                    '/lib.npmtest_discord_io.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-discord.io/node_modules/discord.io/lib/index.js":"\"use strict\";\r\n(function discordio(Discord){\r\nvar isNode = typeof(window) === \"undefined\" && typeof(navigator) === \"undefined\";\r\nvar CURRENT_VERSION = \"2.x.x\",\r\n    GATEWAY_VERSION = 5,\r\n    LARGE_THRESHOLD = 250,\r\n    CONNECT_WHEN = null,\r\n    Endpoints, Payloads;\r\n\r\nif (isNode) {\r\n    var Util        = require('util'),\r\n        FS          = require('fs'),\r\n        UDP         = require('dgram'),\r\n        Zlib        = require('zlib'),\r\n        DNS         = require('dns'),\r\n        Stream      = require('stream'),\r\n        BN          = require('path').basename,\r\n        EE          = require('events').EventEmitter,\r\n        requesters  = {\r\n            http:     require('http'),\r\n            https:    require('https')\r\n        },\r\n        ChildProc   = require('child_process'),\r\n        URL         = require('url'),\r\n        //NPM Modules\r\n        NACL        = require('tweetnacl'),\r\n        Opus        = null;\r\n}\r\n\r\n/* --- Version Check --- */\r\ntry {\r\n\tCURRENT_VERSION = require('../package.json').version;\r\n} catch(e) {}\r\nif (!isNode) CURRENT_VERSION = CURRENT_VERSION + \"-browser\";\r\n\r\n/**\r\n * Discord Client constructor\r\n * @class\r\n * @arg {Object} options\r\n * @arg {String} options.token - The token of the account you wish to log in with.\r\n * @arg {Boolean} [options.autorun] - If true, the client runs when constructed without calling `.connect()`.\r\n * @arg {Number} [options.messageCacheLimit] - The amount of messages to cache in memory, per channel. Used for information on deleted/updated messages. The default is 50.\r\n * @arg {Array<Number>} [options.shard] - The shard array. The first index is the current shard ID, the second is the amount of shards that should be running.\r\n */\r\nDiscord.Client = function DiscordClient(options) {\r\n\tif (!isNode) Emitter.call(this);\r\n\tif (!options || options.constructor.name !== 'Object') return console.error(\"An Object is required to create the discord.io client.\");\r\n\r\n\tapplyProperties(this, [\r\n\t\t[\"_ws\", null],\r\n\t\t[\"_uIDToDM\", {}],\r\n\t\t[\"_ready\", false],\r\n\t\t[\"_vChannels\", {}],\r\n\t\t[\"_messageCache\", {}],\r\n\t\t[\"_connecting\", false],\r\n\t\t[\"_mainKeepAlive\", null],\r\n\t\t[\"_req\", APIRequest.bind(this)],\r\n\t\t[\"_shard\", validateShard(options.shard)],\r\n\t\t[\"_messageCacheLimit\", typeof(options.messageCacheLimit) === 'number' ? options.messageCacheLimit : 50],\r\n\t]);\r\n\r\n\tthis.presenceStatus = \"offline\";\r\n\tthis.connected = false;\r\n\tthis.inviteURL = null;\r\n\tthis.connect = this.connect.bind(this, options);\r\n\r\n\tif (options.autorun === true) this.connect();\r\n};\r\nif (isNode) Emitter.call(Discord.Client);\r\n\r\n/* - DiscordClient - Methods - */\r\nvar DCP = Discord.Client.prototype;\r\n/**\r\n * Manually initiate the WebSocket connection to Discord.\r\n */\r\nDCP.connect = function() {\r\n\tif (!this.connected && !this._connecting) return setTimeout(\r\n\t\tinit,\r\n\t\tMath.max(0, CONNECT_WHEN - Date.now()),\r\n\t\tthis,\r\n\t\targuments[0],\r\n\t\tvoid( CONNECT_WHEN = Math.max(CONNECT_WHEN, Date.now()) + 6000 )\r\n\t);\r\n};\r\n\r\n/**\r\n * Disconnect the WebSocket connection to Discord.\r\n */\r\nDCP.disconnect = function() {\r\n\tif (this._ws) this._ws.close();\r\n};\r\n\r\n/**\r\n * Retrieve a user object from Discord, Bot only endpoint. You don't have to share a server with this user.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.userID\r\n */\r\nDCP.getUser = function(input, callback) {\r\n\tif (!this.bot) return handleErrCB(\"[getUser] This account is a 'user' type account, and cannot use 'getUser'. Only bots can use this endpoint.\", callback);\r\n\tthis._req('get', Endpoints.USER(input.userID), function(err, res) {\r\n\t\thandleResCB(\"Could not get user\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Edit the client's user information.\r\n * @arg {Object} input\r\n * @arg {String<Base64>} input.avatar - The last part of a Base64 Data URI. `fs.readFileSync('image.jpg', 'base64')` is enough.\r\n * @arg {String} input.username - A username.\r\n * @arg {String} input.email - [User only] An email.\r\n * @arg {String} input.password - [User only] Your current password.\r\n * @arg {String} input.new_password - [User only] A new password.\r\n */\r\nDCP.editUserInfo = function(input, callback) {\r\n\tvar payload = {\r\n\t\tavatar: this.avatar,\r\n\t\temail: this.email,\r\n\t\tnew_password: null,\r\n\t\tpassword: null,\r\n\t\tusername: this.username\r\n\t},\r\n\t\tplArr = Object.keys(payload);\r\n\r\n\tfor (var key in input) {\r\n\t\tif (plArr.indexOf(key) < 0) return handleErrCB((\"[editUserInfo] '\" + key + \"' is not a valid key. Valid keys are: \" + plArr.join(\", \")), callback);\r\n\t\tpayload[key] = input[key];\r\n\t}\r\n\tif (input.avatar) payload.avatar = \"data:image/jpg;base64,\" + input.avatar;\r\n\r\n\tthis._req('patch', Endpoints.ME, payload, function(err, res) {\r\n\t\thandleResCB(\"Unable to edit user information\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Change the client's presence.\r\n * @arg {Object} input\r\n * @arg {Number|null} input.idle_since - Use a Number before the current point in time.\r\n * @arg {Object|null} input.game - Used to set game information.\r\n * @arg {String|null} input.game.name - The name of the game.\r\n * @arg {Number|null} input.game.type - Streaming activity, 0 for nothing, 1 for Twitch.\r\n * @arg {String|null} input.game.url - A URL matching the streaming service you've selected.\r\n */\r\nDCP.setPresence = function(input) {\r\n\tvar payload = Payloads.STATUS(input);\r\n\tsend(this._ws, payload);\r\n\r\n\tif (payload.d.idle_since === null) return void(this.presenceStatus = 'online');\r\n\tthis.presenceStatus = 'idle';\r\n};\r\n\r\n/**\r\n * Receive OAuth information for the current client.\r\n */\r\nDCP.getOauthInfo = function(callback) {\r\n\tthis._req('get', Endpoints.OAUTH, function(err, res) {\r\n\t\thandleResCB(\"Error GETing OAuth information\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Receive account settings information for the current client.\r\n */\r\nDCP.getAccountSettings = function(callback) {\r\n\tthis._req('get', Endpoints.SETTINGS, function(err, res) {\r\n\t\thandleResCB(\"Error GETing client settings\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/* - DiscordClient - Methods - Content - */\r\n\r\n/**\r\n * Upload a file to a channel.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.to - The target Channel or User ID.\r\n * @arg {Buffer|String} input.file - A Buffer containing the file data, or a String that's a path to the file.\r\n * @arg {String|null} input.filename - A filename for the uploaded file, required if you provide a Buffer.\r\n * @arg {String|null} input.message - An optional message to provide.\r\n */\r\nDCP.uploadFile = function(input, callback) {\r\n\t/* After like 15 minutes of fighting with Request, turns out Discord doesn't allow multiple files in one message...\r\n\tdespite having an attachments array.*/\r\n\tvar file,\r\n\t\tclient = this, multi = new Multipart(),\tmessage = generateMessage(input.message || \"\"),\r\n\t\tisBuffer = (input.file instanceof Buffer), isString = (type(input.file) === 'string');\r\n\r\n\tif (!isBuffer && !isString) return handleErrCB(\"[uploadFile] uploadFile requires a String or Buffer as the 'file' value\", callback);\r\n\tif (isBuffer) if (input.filename) file = input.file; else return handleErrCB(\"[uploadFile] uploadFile requires a 'filename' value to be set if using a Buffer\", callback);\r\n\tif (isString) try { file = FS.readFileSync(input.file); } catch(e) { return handleErrCB(\"[uploadFile] File does not exist: \" + input.file, callback); }\r\n\r\n\t[\r\n\t\t[\"content\", message.content],\r\n\t\t[\"mentions\", \"\"],\r\n\t\t[\"tts\", false],\r\n\t\t[\"nonce\", message.nonce],\r\n\t\t[\"file\", file, input.filename || BN(input.file)]\r\n\t].forEach(multi.append, multi);\r\n\tmulti.finalize();\r\n\r\n\tresolveID(client, input.to, function(channelID) {\r\n\t\tclient._req('post', Endpoints.MESSAGES(channelID), multi, function(err, res) {\r\n\t\t\thandleResCB(\"Unable to upload file\", err, res, callback);\r\n\t\t});\r\n\t});\r\n};\r\n\r\n/**\r\n * Send a message to a channel.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.to - The target Channel or User ID.\r\n * @arg {String} input.message - The message content.\r\n * @arg {Object} [input.embed] - An embed object to include\r\n * @arg {Boolean} [input.tts] - Enable Text-to-Speech for this message.\r\n * @arg {Number} [input.nonce] - Number-used-only-ONCE. The Discord client uses this to change the message color from grey to white.\r\n * @arg {Boolean} [input.typing] - Indicates whether the message should be sent with simulated typing. Based on message length.\r\n */\r\nDCP.sendMessage = function(input, callback) {\r\n\tvar message = generateMessage(input.message || '', input.embed);\r\n\tmessage.tts = (input.tts === true);\r\n\tmessage.nonce = input.nonce || message.nonce;\r\n\r\n\tif (input.typing === true) {\r\n\t\treturn simulateTyping(\r\n\t\t\tthis,\r\n\t\t\tinput.to,\r\n\t\t\tmessage,\r\n\t\t\t( (message.content.length * 0.12) * 1000 ),\r\n\t\t\tcallback\r\n\t\t);\r\n\t}\r\n\r\n\tsendMessage(this, input.to, message, callback);\r\n};\r\n\r\n/**\r\n * Pull a message object from Discord.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID - The channel ID that the message is from.\r\n * @arg {Snowflake} input.messageID - The ID of the message.\r\n */\r\nDCP.getMessage = function(input, callback) {\r\n\tthis._req('get', Endpoints.MESSAGES(input.channelID, input.messageID), function(err, res) {\r\n\t\thandleResCB(\"Unable to get message\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Pull an array of message objects from Discord.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID - The channel ID to pull the messages from.\r\n * @arg {Number} [input.limit] - How many messages to pull, defaults to 50.\r\n * @arg {Snowflake} [input.before] - Pull messages before this message ID.\r\n * @arg {Snowflake} [input.after] - Pull messages after this message ID.\r\n */\r\nDCP.getMessages = function(input, callback) {\r\n\tvar client = this, qs = {}, messages = [], lastMessageID = \"\";\r\n\tvar total = typeof(input.limit) !== 'number' ? 50 : input.limit;\r\n\r\n\tif (input.before) qs.before = input.before;\r\n\tif (input.after) qs.after = input.after;\r\n\r\n\t(function getMessages() {\r\n\t\tif (total > 100) {\r\n\t\t\tqs.limit = 100;\r\n\t\t\ttotal = total - 100;\r\n\t\t} else {\r\n\t\t\tqs.limit = total;\r\n\t\t}\r\n\r\n\t\tif (messages.length >= input.limit) return call(callback, [null, messages]);\r\n\r\n\t\tclient._req('get', Endpoints.MESSAGES(input.channelID) + qstringify(qs), function(err, res) {\r\n\t\t\tif (err) return handleErrCB(\"Unable to get messages\", callback);\r\n\t\t\tmessages = messages.concat(res.body);\r\n\t\t\tlastMessageID = messages[messages.length - 1] && messages[messages.length - 1].id;\r\n\t\t\tif (lastMessageID) qs.before = lastMessageID;\r\n\t\t\tif (!res.body.length < qs.limit) return call(callback, [null, messages]);\r\n\t\t\treturn setTimeout(getMessages, 1000);\r\n\t\t});\r\n\t})();\r\n};\r\n\r\n/**\r\n * Edit a previously sent message.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID\r\n * @arg {Snowflake} input.messageID\r\n * @arg {Snowflake} input.message - The new message content\r\n * @arg {Object} [input.embed] - The new Discord Embed object\r\n */\r\nDCP.editMessage = function(input, callback) {\r\n\tthis._req('patch', Endpoints.MESSAGES(input.channelID, input.messageID), generateMessage(input.message || '', input.embed), function(err, res) {\r\n\t\thandleResCB(\"Unable to edit message\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Delete a posted message.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID\r\n * @arg {Snowflake} input.messageID\r\n */\r\nDCP.deleteMessage = function(input, callback) {\r\n\tthis._req('delete', Endpoints.MESSAGES(input.channelID, input.messageID), function(err, res) {\r\n\t\thandleResCB(\"Unable to delete message\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Delete a batch of messages.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID\r\n * @arg {Array<Snowflake>} input.messageIDs - An Array of message IDs, with a maximum of 100 indexes.\r\n */\r\nDCP.deleteMessages = function(input, callback) {\r\n\tthis._req('post', Endpoints.BULK_DELETE(input.channelID), {messages: input.messageIDs.slice(0, 100)}, function(err, res) {\r\n\t\thandleResCB(\"Unable to delete messages\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Pin a message to the channel.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID\r\n * @arg {Snowflake} input.messageID\r\n */\r\nDCP.pinMessage = function(input, callback) {\r\n\tthis._req('put', Endpoints.PINNED_MESSAGES(input.channelID, input.messageID), function(err, res) {\r\n\t\thandleResCB(\"Unable to pin message\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Get an array of pinned messages from a channel.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID\r\n */\r\nDCP.getPinnedMessages = function(input, callback) {\r\n\tthis._req('get', Endpoints.PINNED_MESSAGES(input.channelID), function(err, res) {\r\n\t\thandleResCB(\"Unable to get pinned messages\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Delete a pinned message from a channel.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID\r\n * @arg {Snowflake} input.messageID\r\n */\r\nDCP.deletePinnedMessage = function(input, callback) {\r\n\tthis._req('delete', Endpoints.PINNED_MESSAGES(input.channelID, input.messageID), function(err, res) {\r\n\t\thandleResCB(\"Unable to delete pinned message\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Send 'typing...' status to a channel\r\n * @arg {Snowflake} channelID\r\n */\r\nDCP.simulateTyping = function(channelID, callback) {\r\n\tthis._req('post', Endpoints.TYPING(channelID), function(err, res) {\r\n\t\thandleResCB(\"Unable to simulate typing\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Replace Snowflakes with the names if applicable.\r\n * @arg {String} message - The message to fix.\r\n */\r\nDCP.fixMessage = function(message) {\r\n\tvar client = this;\r\n\treturn message.replace(/<@&(\\d*)>|<@!(\\d*)>|<@(\\d*)>|<#(\\d*)>/g, function(match, RID, NID, UID, CID) {\r\n\t\tvar k, i;\r\n\t\tif (UID || CID) {\r\n\t\t\tif (client.users[UID]) return \"@\" + client.users[UID].username;\r\n\t\t\tif (client.channels[CID]) return \"#\" + client.channels[CID].name;\r\n\t\t}\r\n\t\tif (RID || NID) {\r\n\t\t\tk = Object.keys(client.servers);\r\n\t\t\tfor (i=0; i<k.length; i++) {\r\n\t\t\t\tif (client.servers[k[i]].roles[RID]) return \"@\" + client.servers[k[i]].roles[RID].name;\r\n\t\t\t\tif (client.servers[k[i]].members[NID]) return \"@\" + client.servers[k[i]].members[NID].nick;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n};\r\n\r\n/**\r\n * Add an emoji reaction to a message.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID\r\n * @arg {Snowflake} input.messageID\r\n * @arg {String} input.reaction - Either the emoji unicode or the emoji name:id/object.\r\n */\r\nDCP.addReaction = function(input, callback) {\r\n\tthis._req('put', Endpoints.USER_REACTIONS(input.channelID, input.messageID, stringifyEmoji(input.reaction)), function(err, res) {\r\n\t\thandleResCB(\"Unable to add reaction\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Get an emoji reaction of a message.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID\r\n * @arg {Snowflake} input.messageID\r\n * @arg {String} input.reaction - Either the emoji unicode or the emoji name:id/object.\r\n * @arg {String} [input.limit]\r\n */\r\nDCP.getReaction = function(input, callback) {\r\n\tvar qs = { limit: (typeof(input.limit) !== 'number' ? 100 : input.limit) };\r\n\tthis._req('get', Endpoints.MESSAGE_REACTIONS(input.channelID, input.messageID, stringifyEmoji(input.reaction)) + qstringify(qs), function(err, res) {\r\n\t\thandleResCB(\"Unable to get reaction\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Remove an emoji reaction from a message.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID\r\n * @arg {Snowflake} input.messageID\r\n * @arg {Snowflake} [input.userID]\r\n * @arg {String} input.reaction - Either the emoji unicode or the emoji name:id/object.\r\n */\r\nDCP.removeReaction = function(input, callback) {\r\n\tthis._req('delete', Endpoints.USER_REACTIONS(input.channelID, input.messageID, stringifyEmoji(input.reaction), input.userID), function(err, res) {\r\n\t\thandleResCB(\"Unable to remove reaction\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Remove all emoji reactions from a message.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID\r\n * @arg {Snowflake} input.messageID\r\n */\r\nDCP.removeAllReactions = function(input, callback) {\r\n\tthis._req('delete', Endpoints.MESSAGE_REACTIONS(input.channelID, input.messageID), function(err, res) {\r\n\t\thandleResCB(\"Unable to remove reactions\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/* - DiscordClient - Methods - Server Management - */\r\n\r\n/**\r\n * Remove a user from a server.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.userID\r\n */\r\nDCP.kick = function(input, callback) {\r\n\tthis._req('delete', Endpoints.MEMBERS(input.serverID, input.userID), function(err, res) {\r\n\t\thandleResCB(\"Could not kick user\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Remove and ban a user from a server.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.userID\r\n * @arg {Number} [input.lastDays] - Removes their messages up until this point, either 1 or 7 days.\r\n */\r\nDCP.ban = function(input, callback) {\r\n\tif (input.lastDays) {\r\n\t\tinput.lastDays = Number(input.lastDays);\r\n\t\tinput.lastDays = Math.min(input.lastDays, 7);\r\n\t\tinput.lastDays = Math.max(input.lastDays, 1);\r\n\t}\r\n\r\n\tthis._req('put', Endpoints.BANS(input.serverID, input.userID) + (input.lastDays ? \"?delete-message-days=\" + input.lastDays : \"\"), function(err, res) {\r\n\t\thandleResCB(\"Could not ban user\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Unban a user from a server.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.userID\r\n */\r\nDCP.unban = function(input, callback) {\r\n\tthis._req('delete', Endpoints.BANS(input.serverID, input.userID), function(err, res) {\r\n\t\thandleResCB(\"Could not unban user\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Move a user between voice channels.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.userID\r\n * @arg {Snowflake} input.channelID\r\n */\r\nDCP.moveUserTo = function(input, callback) {\r\n\tthis._req('patch', Endpoints.MEMBERS(input.serverID, input.userID), {channel_id: input.channelID}, function(err, res) {\r\n\t\thandleResCB(\"Could not move the user\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Server-mute the user from speaking in all voice channels.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.userID\r\n */\r\nDCP.mute = function(input, callback) {\r\n\tthis._req('patch', Endpoints.MEMBERS(input.serverID, input.userID), {mute: true}, function(err, res) {\r\n\t\thandleResCB(\"Could not mute user\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Remove the server-mute from a user.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.userID\r\n */\r\nDCP.unmute = function(input, callback) {\r\n\tthis._req('patch', Endpoints.MEMBERS(input.serverID, input.userID), {mute: false}, function(err, res) {\r\n\t\thandleResCB(\"Could not unmute user\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Server-deafan a user.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.userID\r\n */\r\nDCP.deafen = function(input, callback) {\r\n\tthis._req('patch', Endpoints.MEMBERS(input.serverID, input.userID), {deaf: true}, function(err, res) {\r\n\t\thandleResCB(\"Could not deafen user\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Remove the server-deafan from a user.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.userID\r\n */\r\nDCP.undeafen = function(input, callback) {\r\n\tthis._req('patch', Endpoints.MEMBERS(input.serverID, input.userID), {deaf: false}, function(err, res) {\r\n\t\thandleResCB(\"Could not undeafen user\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/*Bot server management actions*/\r\n\r\n/**\r\n * Create a server [User only].\r\n * @arg {Object} input\r\n * @arg {String} input.name - The server's name\r\n * @arg {String} [input.region] - The server's region code, check the Gitbook documentation for all of them.\r\n * @arg {String<Base64>} [input.icon] - The last part of a Base64 Data URI. `fs.readFileSync('image.jpg', 'base64')` is enough.\r\n */\r\nDCP.createServer = function(input, callback) {\r\n\tvar payload, client = this;\r\n\tpayload = {icon: null, name: null, region: null};\r\n\tfor (var key in input) {\r\n\t\tif (Object.keys(payload).indexOf(key) < 0) continue;\r\n\t\tpayload[key] = input[key];\r\n\t}\r\n\tif (input.icon) payload.icon = \"data:image/jpg;base64,\" + input.icon;\r\n\r\n\tclient._req('post', Endpoints.SERVERS(), payload, function(err, res) {\r\n\t\ttry {\r\n\t\t\tclient.servers[res.body.id] = {};\r\n\t\t\tcopyKeys(res.body, client.servers[res.body.id]);\r\n\t\t} catch(e) {}\r\n\t\thandleResCB(\"Could not create server\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Edit server information.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {String} [input.name]\r\n * @arg {String} [input.icon]\r\n * @arg {String} [input.region]\r\n * @arg {Snowflake} [input.afk_channel_id] - The ID of the voice channel to move a user to after the afk period.\r\n * @arg {Number} [input.afk_timeout] - Time in seconds until a user is moved to the afk channel. 60, 300, 900, 1800, or 3600.\r\n */\r\nDCP.editServer = function(input, callback) {\r\n\tvar payload, serverID = input.serverID, server, client = this;\r\n\tif (!client.servers[serverID]) return handleErrCB((\"[editServer] Server \" + serverID + \" not found.\"), callback);\r\n\r\n\tserver = client.servers[serverID];\r\n\tpayload = {\r\n\t\tname: server.name,\r\n\t\ticon: server.icon,\r\n\t\tregion: server.region,\r\n\t\tafk_channel_id: server.afk_channel_id,\r\n\t\tafk_timeout: server.afk_timeout\r\n\t};\r\n\r\n\tfor (var key in input) {\r\n\t\tif (Object.keys(payload).indexOf(key) < 0) continue;\r\n\t\tif (key === 'afk_channel_id') {\r\n\t\t\tif (server.channels[input[key]] && server.channels[input[key]].type === 'voice') payload[key] = input[key];\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (key === 'afk_timeout') {\r\n\t\t\tif ([60, 300, 900, 1800, 3600].indexOf(Number(input[key])) > -1) payload[key] = input[key];\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tpayload[key] = input[key];\r\n\t}\r\n\tif (input.icon) payload.icon = \"data:image/jpg;base64,\" + input.icon;\r\n\r\n\tclient._req('patch', Endpoints.SERVERS(input.serverID), payload, function(err, res) {\r\n\t\thandleResCB(\"Unable to edit server\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Edit the widget information for a server.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID - The ID of the server whose widget you want to edit.\r\n * @arg {Boolean} [input.enabled] - Whether or not you want the widget to be enabled.\r\n * @arg {Snowflake} [input.channelID] - [Important] The ID of the channel you want the instant invite to point to.\r\n */\r\nDCP.editServerWidget = function(input, callback) {\r\n\tvar client = this, payload, url = Endpoints.SERVERS(input.serverID) + \"/embed\";\r\n\r\n\tclient._req('get', url, function(err, res) {\r\n\t\tif (err) return handleResCB(\"Unable to GET server widget settings. Can not edit without retrieving first.\", err, res, callback);\r\n\t\tpayload = {\r\n\t\t\tenabled: ('enabled' in input ? input.enabled : res.body.enabled),\r\n\t\t\tchannel_id: ('channelID' in input ? input.channelID : res.body.channel_id)\r\n\t\t};\r\n\t\tclient._req('patch', url, payload, function(err, res) {\r\n\t\t\thandleResCB(\"Unable to edit server widget\", err, res, callback);\r\n\t\t});\r\n\t});\r\n};\r\n\r\n/**\r\n * [User Account] Add an emoji to a server\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {String} input.name - The emoji's name\r\n * @arg {String<Base64>} input.image - The emoji's image data in Base64\r\n */\r\nDCP.addServerEmoji = function(input, callback) {\r\n\tvar payload = {\r\n\t\tname: input.name,\r\n\t\timage: \"data:image/png;base64,\" + input.image\r\n\t};\r\n\tthis._req('post', Endpoints.SERVER_EMOJIS(input.serverID), payload, function(err, res) {\r\n\t\thandleResCB(\"Unable to add emoji to the server\", err, res, callback);\r\n\t});\r\n}\r\n\r\n/**\r\n * [User Account] Edit a server emoji data (name only, currently)\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.emojiID - The emoji's ID\r\n * @arg {String} [input.name]\r\n * @arg {Array<Snowflake>} [input.roles] - An array of role IDs you want to limit the emoji's usage to\r\n */\r\nDCP.editServerEmoji = function(input, callback) {\r\n\tvar emoji, payload = {};\r\n\tif ( !this.servers[input.serverID] ) return handleErrCB((\"[editServerEmoji] Server not available: \" + input.serverID), callback);\r\n\tif ( !this.servers[input.serverID].emojis[input.emojiID]) return handleErrCB((\"[editServerEmoji] Emoji not available: \" + input.emojiID), callback);\r\n\r\n\temoji = this.servers[input.serverID].emojis[input.emojiID];\r\n\tpayload.name = input.name || emoji.name;\r\n\tpayload.roles = input.roles || emoji.roles;\r\n\r\n\tthis._req('patch', Endpoints.SERVER_EMOJIS(input.serverID, input.emojiID), payload, function(err, res) {\r\n\t\thandleResCB(\"[editServerEmoji] Could not edit server emoji\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * [User Account] Remove an emoji from a server\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.emojiID\r\n */\r\nDCP.deleteServerEmoji = function(input, callback) {\r\n\tthis._req('delete', Endpoints.SERVER_EMOJIS(input.serverID, input.emojiID), function(err, res) {\r\n\t\thandleResCB(\"[deleteServerEmoji] Could not delete server emoji\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Leave a server.\r\n * @arg {Snowflake} serverID\r\n */\r\nDCP.leaveServer = function(serverID, callback) {\r\n\tthis._req('delete', Endpoints.SERVERS_PERSONAL(serverID), function(err, res) {\r\n\t\thandleResCB(\"Could not leave server\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Delete a server owned by the client.\r\n * @arg {Snowflake} serverID\r\n */\r\nDCP.deleteServer = function(serverID, callback) {\r\n\tthis._req('delete', Endpoints.SERVERS(serverID), function(err, res) {\r\n\t\thandleResCB(\"Could not delete server\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Transfer ownership of a server to another user.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.userID\r\n */\r\nDCP.transferOwnership = function(input, callback) {\r\n\tthis._req('patch', Endpoints.SERVERS(input.serverID), {owner_id: input.userID}, function(err, res) {\r\n\t\thandleResCB(\"Could not transfer server ownership\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Accept an invite to a server [User Only]\r\n * @arg {String} inviteCode - The code part of an invite URL (e.g. 0MvHMfHcTKVVmIGP)\r\n */\r\nDCP.acceptInvite = function(inviteCode, callback) {\r\n\tif (this.bot) return handleErrCB(\"[acceptInvite] This account is a 'bot' type account, and cannot use 'acceptInvite'. Please use the client's inviteURL property instead.\", callback);\r\n\tvar client = this, joinedServers = Object.keys(client.servers);\r\n\tthis._req('post', Endpoints.INVITES(inviteCode), function(err, res) {\r\n\t\ttry {\r\n\t\t\t//Try to create the server with the small amount of data\r\n\t\t\t//that Discord provides directly from the HTTP response\r\n\t\t\t//since the websocket event may take a second to show.\r\n\t\t\tif (!client.servers[res.body.guild.id]) {\r\n\t\t\t\tclient.servers[res.body.guild.id] = res.body.guild;\r\n\t\t\t\tclient.servers[res.body.guild.id].channels = {};\r\n\t\t\t\tclient.servers[res.body.guild.id].channels[res.body.channel.id] = res.body.channel;\r\n\t\t\t} else {\r\n\t\t\t\tif (joinedServers.indexOf(res.body.guild.id) > -1) {\r\n\t\t\t\t\treturn handleErrCB((\"Already joined server: \" + res.body.guild.id), callback);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch(e) {}\r\n\t\thandleResCB((\"The invite code provided \" + inviteCode + \" is incorrect.\"), err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Generate an invite URL for a channel.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID\r\n * @arg {Number} [input.max_age] - Time in seconds.\r\n * @arg {Number} [input.max_users] - The amount of times the invite code can be used.\r\n * @arg {Boolean} [input.temporary] - Any users who use this invite will be removed when they disconnect, unless given a role.\r\n */\r\nDCP.createInvite = function(input, callback) {\r\n\tvar payload, client = this;\r\n\r\n\tpayload = {\r\n\t\tmax_age: 0,\r\n\t\tmax_users: 0,\r\n\t\ttemporary: false\r\n\t};\r\n\r\n\tif ( Object.keys(input).length === 1 && input.channelID ) {\r\n\t\tpayload = {\r\n\t\t\tvalidate: client.internals.lastInviteCode || null\r\n\t\t};\r\n\t}\r\n\r\n\tfor (var key in input) {\r\n\t\tif (Object.keys(payload).indexOf(key) < 0) continue;\r\n\t\tpayload[key] = input[key];\r\n\t}\r\n\r\n\tthis._req('post', Endpoints.CHANNEL(input.channelID) + \"/invites\", payload, function(err, res) {\r\n\t\ttry {client.internals.lastInviteCode = res.body.code;} catch(e) {}\r\n\t\thandleResCB('Unable to create invite', err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Delete an invite code.\r\n * @arg {String} inviteCode\r\n */\r\nDCP.deleteInvite = function(inviteCode, callback) {\r\n\tthis._req('delete', Endpoints.INVITES(inviteCode), function(err, res) {\r\n\t\thandleResCB('Unable to delete invite', err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Get information on an invite.\r\n * @arg {String} inviteCode\r\n */\r\nDCP.queryInvite = function(inviteCode, callback) {\r\n\tthis._req('get', Endpoints.INVITES(inviteCode), function(err, res) {\r\n\t\thandleResCB('Unable to get information about invite', err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Get all invites for a server.\r\n * @arg {Snowflake} serverID\r\n */\r\nDCP.getServerInvites = function(serverID, callback) {\r\n\tthis._req('get', Endpoints.SERVERS(serverID) + \"/invites\", function(err, res) {\r\n\t\thandleResCB('Unable to get invite list for server' + serverID, err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Get all invites for a channel.\r\n * @arg {Snowflake} channelID\r\n */\r\nDCP.getChannelInvites = function(channelID, callback) {\r\n\tthis._req('get', Endpoints.CHANNEL(channelID) + \"/invites\", function(err, res) {\r\n\t\thandleResCB('Unable to get invite list for channel' + channelID, err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Create a channel.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {String} input.name\r\n * @arg {String} [input.type] - 'text' or 'voice', defaults to 'text.\r\n */\r\nDCP.createChannel = function(input, callback) {\r\n\tvar client = this, payload = {\r\n\t\tname: input.name,\r\n\t\ttype: (['text', 'voice'].indexOf(input.type) < 0) ? 'text' : input.type\r\n\t};\r\n\r\n\tthis._req('post', Endpoints.SERVERS(input.serverID) + \"/channels\", payload, function(err, res) {\r\n\t\ttry {\r\n\t\t\tvar serverID = res.body.guild_id;\r\n\t\t\tvar channelID = res.body.id;\r\n\r\n\t\t\tclient.channels[channelID] = new Channel( client, client.servers[serverID], res.body );\r\n\t\t} catch(e) {}\r\n\t\thandleResCB('Unable to create channel', err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Create a Direct Message channel.\r\n * @arg {Snowflake} userID\r\n */\r\nDCP.createDMChannel = function(userID, callback) {\r\n\tvar client = this;\r\n\tthis._req('post', Endpoints.USER(client.id) + \"/channels\", {recipient_id: userID}, function(err, res) {\r\n\t\tif (!err && goodResponse(res)) client._uIDToDM[res.body.recipient.id] = res.body.id;\r\n\t\thandleResCB(\"Unable to create DM Channel\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Delete a channel.\r\n * @arg {Snowflake} channelID\r\n */\r\nDCP.deleteChannel = function(channelID, callback) {\r\n\tthis._req('delete', Endpoints.CHANNEL(channelID), function(err, res) {\r\n\t\thandleResCB(\"Unable to delete channel\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Edit a channel's information.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.channelID\r\n * @arg {String} [input.name]\r\n * @arg {String} [input.topic] - The topic of the channel.\r\n * @arg {Number} [input.bitrate] - [Voice Only] The bitrate for the channel.\r\n * @arg {Number} [input.position] - The channel's position on the list.\r\n * @arg {Number} [input.user_limit] - [Voice Only] Imposes a user limit on a voice channel.\r\n */\r\nDCP.editChannelInfo = function(input, callback) {\r\n\tvar channel, payload;\r\n\r\n\ttry {\r\n\t\tchannel = this.channels[input.channelID];\r\n\t\tpayload = {\r\n\t\t\tname: channel.name,\r\n\t\t\ttopic: channel.topic,\r\n\t\t\tbitrate: channel.bitrate,\r\n\t\t\tposition: channel.position,\r\n\t\t\tuser_limit: channel.user_limit\r\n\t\t};\r\n\r\n\t\tfor (var key in input) {\r\n\t\t\tif (Object.keys(payload).indexOf(key) < 0) continue;\r\n\t\t\tif (+input[key]) {\r\n\t\t\t\tif (key === 'bitrate') {\r\n\t\t\t\t\tpayload.bitrate = Math.min( Math.max( input.bitrate, 8000), 96000);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (key === 'user_limit') {\r\n\t\t\t\t\tpayload.user_limit = Math.min( Math.max( input.user_limit, 0), 99);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tpayload[key] = input[key];\r\n\t\t}\r\n\r\n\t\tthis._req('patch', Endpoints.CHANNEL(input.channelID), payload, function(err, res) {\r\n\t\t\thandleResCB(\"Unable to edit channel\", err, res, callback);\r\n\t\t});\r\n\t} catch(e) {return handleErrCB(e, callback);}\r\n};\r\n\r\n/**\r\n * Edit (or creates) a permission override for a channel.\r\n * @arg {Object} input\r\n * @arg {Snowflake} channelID\r\n * @arg {Snowflake} [userID]\r\n * @arg {Snowflake} [roleID]\r\n * @arg {Array<Number>} allow - An array of permissions to allow. Discord.Permissions.XXXXXX.\r\n * @arg {Array<Number>} deny - An array of permissions to deny, same as above.\r\n * @arg {Array<Number>} default - An array of permissions that cancels out allowed and denied permissions.\r\n */\r\nDCP.editChannelPermissions = function(input, callback) { //Will shrink this up later\r\n\tvar payload, pType, ID, channel, permissions, allowed_values;\r\n\tif (!input.userID && !input.roleID) return handleErrCB(\"[editChannelPermissions] No userID or roleID provided\", callback);\r\n\tif (!this.channels[input.channelID]) return handleErrCB((\"[editChannelPermissions] No channel found for ID: \" + input.channelID), callback);\r\n\tif (!input.allow && !input.deny && !input.default) return handleErrCB(\"[editChannelPermissions] No allow, deny or default array provided.\", callback);\r\n\r\n\tpType = input.userID ? 'user' : 'role';\r\n\tID = input[pType + \"ID\"];\r\n\tchannel = this.channels[ input.channelID ];\r\n\tpermissions = channel.permissions[pType][ID] || { allow: 0, deny: 0 };\r\n\tallowed_values = [0, 4, 28].concat((channel.type === 'text' ?\r\n\t[10, 11, 12, 13, 14, 15, 16, 17, 18] :\r\n\t[20, 21, 22, 23, 24, 25] ));\r\n\r\n\t//Take care of allow first\r\n\tif (type(input.allow) === 'array') {\r\n\t\tinput.allow.forEach(function(perm) {\r\n\t\t\tif (allowed_values.indexOf(perm) < 0) return;\r\n\t\t\tif (hasPermission(perm, permissions.deny)) {\r\n\t\t\t\tpermissions.deny = removePermission(perm, permissions.deny);\r\n\t\t\t}\r\n\t\t\tpermissions.allow = givePermission(perm, permissions.allow);\r\n\t\t});\r\n\t}\r\n\t//Take care of deny second\r\n\tif (type(input.deny) === 'array') {\r\n\t\tinput.deny.forEach(function(perm) {\r\n\t\t\tif (allowed_values.indexOf(perm) < 0) return;\r\n\t\t\tif (hasPermission(perm, permissions.allow)) {\r\n\t\t\t\tpermissions.allow = removePermission(perm, permissions.allow);\r\n\t\t\t}\r\n\t\t\tpermissions.deny = givePermission(perm, permissions.deny);\r\n\t\t});\r\n\t}\r\n\t//Take care of defaulting last\r\n\tif (type(input.default) === 'array') {\r\n\t\tinput.default.forEach(function(perm) {\r\n\t\t\tif (allowed_values.indexOf(perm) < 0) return;\r\n\t\t\tpermissions.allow = removePermission(perm, permissions.allow);\r\n\t\t\tpermissions.deny = removePermission(perm, permissions.deny);\r\n\t\t});\r\n\t}\r\n\r\n\tpayload = {\r\n\t\ttype: (pType === 'user' ? 'member' : 'role'),\r\n\t\tid: ID,\r\n\t\tdeny: permissions.deny,\r\n\t\tallow: permissions.allow\r\n\t};\r\n\r\n\tthis._req('put', Endpoints.CHANNEL(input.channelID) + \"/permissions/\" + ID, payload, function(err, res) {\r\n\t\thandleResCB('Unable to edit permission', err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Delete a permission override for a channel.\r\n * @arg {Object} input\r\n * @arg {Snowflake} channelID\r\n * @arg {Snowflake} [userID]\r\n * @arg {Snowflake} [roleID]\r\n */\r\nDCP.deleteChannelPermission = function(input, callback) {\r\n\tvar payload, pType, ID;\r\n\tif (!input.userID && !input.roleID) return handleErrCB(\"[deleteChannelPermission] No userID or roleID provided\", callback);\r\n\tif (!this.channels[input.channelID]) return handleErrCB((\"[deleteChannelPermission] No channel found for ID: \" + input.channelID), callback);\r\n\r\n\tpType = input.userID ? 'user' : 'role';\r\n\tID = input[pType + \"ID\"];\r\n\r\n\tpayload = {\r\n\t\ttype: (pType === 'user' ? 'member' : 'role'),\r\n\t\tid: ID\r\n\t};\r\n\r\n\tthis._req('delete', Endpoints.CHANNEL(input.channelID) + \"/permissions/\" + ID, payload, function(err, res) {\r\n\t\thandleResCB('Unable to delete permission', err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Create a role for a server.\r\n * @arg {Snowflake} serverID\r\n */\r\nDCP.createRole = function(serverID, callback) {\r\n\tvar client = this;\r\n\tthis._req('post', Endpoints.ROLES(serverID), function(err, res) {\r\n\t\ttry {\r\n\t\t\tclient.servers[serverID].roles[res.body.id] = new Role(res.body);\r\n\t\t} catch(e) {}\r\n\t\thandleResCB(\"Unable to create role\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Edit a role.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.roleID - The ID of the role.\r\n * @arg {String} [input.name]\r\n * @arg {String} [input.color] - A color value as a number. Recommend using Hex numbers, as they can map to HTML colors (0xF35353 === #F35353).\r\n * @arg {Boolean} [input.hoist] - Separates the users in this role from the normal online users.\r\n * @arg {Object} [input.permissions] - An Object containing the permission as a key, and `true` or `false` as its value. Read the Permissions doc.\r\n * @arg {Boolean} [input.mentionable] - Toggles if users can @Mention this role.\r\n */\r\nDCP.editRole = function(input, callback) {\r\n\tvar role, payload;\r\n\ttry {\r\n\t\trole = new Role(this.servers[input.serverID].roles[input.roleID]);\r\n\t\tpayload = {\r\n\t\t\tname: role.name,\r\n\t\t\tcolor: role.color,\r\n\t\t\thoist: role.hoist,\r\n\t\t\tpermissions: role._permissions,\r\n\t\t\tmentionable: role.mentionable,\r\n\t\t\tposition: role.position\r\n\t\t};\r\n\r\n\t\tfor (var key in input) {\r\n\t\t\tif (Object.keys(payload).indexOf(key) < 0) continue;\r\n\t\t\tif (key === 'permissions') {\r\n\t\t\t\tfor (var perm in input[key]) {\r\n\t\t\t\t\trole[perm] = input[key][perm];\r\n\t\t\t\t\tpayload.permissions = role._permissions;\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (key === 'color') {\r\n\t\t\t\tif (String(input[key])[0] === '#') payload.color = parseInt(String(input[key]).replace('#', '0x'), 16);\r\n\t\t\t\tif (Discord.Colors[input[key]]) payload.color = Discord.Colors[input[key]];\r\n\t\t\t\tif (type(input[key]) === 'number') payload.color = input[key];\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tpayload[key] = input[key];\r\n\t\t}\r\n\t\tthis._req('patch', Endpoints.ROLES(input.serverID, input.roleID), payload, function(err, res) {\r\n\t\t\thandleResCB(\"Unable to edit role\", err, res, callback);\r\n\t\t});\r\n\t} catch(e) {return handleErrCB(('[editRole] ' + e), callback);}\r\n};\r\n\r\n/**\r\n * Delete a role.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.roleID\r\n */\r\nDCP.deleteRole = function(input, callback) {\r\n\tthis._req('delete', Endpoints.ROLES(input.serverID, input.roleID), function(err, res) {\r\n\t\thandleResCB(\"Could not remove role\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Add a user to a role.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.roleID\r\n * @arg {Snowflake} input.userID\r\n */\r\nDCP.addToRole = function(input, callback) {\r\n\tthis._req('put', Endpoints.MEMBER_ROLES(input.serverID, input.userID, input.roleID), function(err, res) {\r\n\t\thandleResCB(\"Could not add role\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Remove a user from a role.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.roleID\r\n * @arg {Snowflake} input.userID\r\n */\r\nDCP.removeFromRole = function(input, callback) {\r\n\tthis._req('delete', Endpoints.MEMBER_ROLES(input.serverID, input.userID, input.roleID), function(err, res) {\r\n\t\thandleResCB(\"Could not remove role\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Edit a user's nickname.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.userID\r\n * @arg {String} input.nick - The nickname you'd like displayed.\r\n */\r\nDCP.editNickname = function(input, callback) {\r\n\tvar payload = {nick: String( input.nick ? input.nick : \"\" )};\r\n\tvar url = input.userID === this.id ?\r\n\t\tEndpoints.MEMBERS(input.serverID) + \"/@me/nick\" :\r\n\t\tEndpoints.MEMBERS(input.serverID, input.userID);\r\n\r\n\tthis._req('patch', url, payload, function(err, res) {\r\n\t\thandleResCB(\"Could not change nickname\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Edit a user's note.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.userID\r\n * @arg {String} input.note - The note content that you want to use.\r\n */\r\nDCP.editNote = function(input, callback) {\r\n\tthis._req('put', Endpoints.NOTE(input.userID), {note: input.note}, function(err, res) {\r\n\t\thandleResCB(\"Could not edit note\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Retrieve a user object from Discord, the library already caches users, however.\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.serverID\r\n * @arg {Snowflake} input.userID\r\n */\r\nDCP.getMember = function(input, callback) {\r\n\tthis._req('get', Endpoints.MEMBERS(input.serverID, input.userID), function(err, res) {\r\n\t\thandleResCB(\"Could not get member\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Retrieve a group of user objects from Discord.\r\n * @arg {Object} input\r\n * @arg {Number} [input.limit] - The amount of users to pull, defaults to 50.\r\n * @arg {Snowflake} [input.after] - The offset using a user ID.\r\n */\r\nDCP.getMembers = function(input, callback) {\r\n\tvar qs = {};\r\n\tqs.limit = (typeof(input.limit) !== 'number' ? 50 : input.limit);\r\n\tif (input.after) qs.after = input.after;\r\n\r\n\tthis._req('get', Endpoints.MEMBERS(input.serverID) + qstringify(qs), function(err, res) {\r\n\t\thandleResCB(\"Could not get members\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Get the ban list from a server\r\n * @arg {Snowflake} serverID\r\n */\r\nDCP.getBans = function(serverID, callback) {\r\n\tthis._req('get', Endpoints.BANS(serverID), function(err, res) {\r\n\t\thandleResCB(\"Could not get ban list\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Get all webhooks for a server\r\n * @arg {Snowflake} serverID\r\n */\r\nDCP.getServerWebhooks = function(serverID, callback) {\r\n\tthis._req('get', Endpoints.SERVER_WEBHOOKS(serverID), function(err, res) {\r\n\t\thandleResCB(\"Could not get server Webhooks\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Get webhooks from a channel\r\n * @arg {Snowflake} channelID\r\n */\r\nDCP.getChannelWebhooks = function(channelID, callback) {\r\n\tthis._req('get', Endpoints.CHANNEL_WEBHOOKS(channelID), function(err, res) {\r\n\t\thandleResCB(\"Could not get channel Webhooks\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Create a webhook for a server\r\n * @arg {Snowflake} serverID\r\n */\r\nDCP.createWebhook = function(serverID, callback) {\r\n\tthis._req('post', Endpoints.SERVER_WEBHOOKS(serverID), function(err, res) {\r\n\t\thandleResCB(\"Could not create a Webhook\", err, res, callback);\r\n\t});\r\n};\r\n\r\n/**\r\n * Edit a webhook\r\n * @arg {Object} input\r\n * @arg {Snowflake} input.webhookID - The Webhook's ID\r\n * @arg {String} [input.name]\r\n * @arg {String<Base64>} [input.avatar]\r\n * @arg {String} [input.channelID]\r\n */\r\nDCP.editWebhook = function(input, callback) {\r\n\tvar client = this, payload = {}, allowed = ['avatar', 'name'];\r\n\tthis._req('get', Endpoints.WEBHOOKS(input.webhookID), function(err, res) {\r\n\t\tif (err || !goodResponse(res)) return handleResCB(\"Couldn't get webhook, do you have permissions to access it?\", err, res, callback);\r\n\t\tallowed.forEach(function(key) {\r\n\t\t\tpayload[key] = (key in input ? input[key] : res.body[key]);\r\n\t\t});\r\n\t\tpayload.channel_id = input.channelID || res.body.channel_id;\r\n\r\n\t\tclient._req('patch', Endpoints.WEBHOOKS(input.webhookID), payload, function(err, res) {\r\n\t\t\treturn handleResCB(\"Couldn't update webhook\", err, res, callback);\r\n\t\t});\r\n\t});\r\n};\r\n\r\n/* --- Voice --- */\r\n\r\n/**\r\n * Join a voice channel.\r\n * @arg {Snowflake} channelID\r\n */\r\nDCP.joinVoiceChannel = function(channelID, callback) {\r\n\tvar serverID, server, channel, voiceSession;\r\n\ttry {\r\n\t\tserverID = this.channels[channelID].guild_id;\r\n\t\tserver = this.servers[serverID];\r\n\t\tchannel = server.channels[channelID];\r\n\t} catch(e) {}\r\n\tif (!serverID) return handleErrCB((\"Cannot find the server related to the channel provided: \" + channelID), callback);\r\n\tif (channel.type !== 'voice') return handleErrCB((\"Selected channel is not a voice channel: \" + channelID), callback);\r\n\tif (this._vChannels[channelID]) return handleErrCB((\"Voice channel already active: \" + channelID), callback);\r\n\r\n\tvoiceSession = getVoiceSession(this, channelID, server);\r\n\tcheckVoiceReady(voiceSession, callback);\r\n\treturn send(this._ws, Payloads.UPDATE_VOICE(serverID, channelID));\r\n};\r\n\r\n/**\r\n * Leave a voice channel.\r\n * @arg {Snowflake} channelID\r\n */\r\nDCP.leaveVoiceChannel = function(channelID, callback) {\r\n\tif (!this._vChannels[channelID]) return handleErrCB((\"Not in the voice channel: \" + channelID), callback);\r\n\treturn leaveVoiceChannel(this, channelID, callback);\r\n};\r\n\r\n/**\r\n * Prepare the client for sending/receiving audio.\r\n * @arg {Snowflake|Object} channelObj - Either the channel ID, or an Object with `channelID` as a key and the ID as the value.\r\n * @arg {Number} [channelObj.maxStreamSize] - The size in KB that you wish to receive before pushing out earlier data. Required if you want to store or receive incoming audio.\r\n * @arg {Boolean} [channelObj.stereo] - Sets the audio to be either stereo or mono. Defaults to true.\r\n */\r\nDCP.getAudioContext = function(channelObj, callback) {\r\n\t// #q/qeled gave a proper timing solution. Credit where it's due.\r\n\tif (!isNode) return handleErrCB(\"Using audio in the browser is currently not supported.\", callback);\r\n\tvar channelID = channelObj.channelID || channelObj, voiceSession = this._vChannels[channelID], encoder = chooseAudioEncoder(['ffmpeg', 'avconv']);\r\n\r\n\tif (!voiceSession) return handleErrCB((\"You have not joined the voice channel: \" + channelID), callback);\r\n\tif (voiceSession.ready !== true) return handleErrCB((\"The connection to the voice channel \" + channelID + \" has not been initialized yet.\"), callback);\r\n\tif (!encoder) return handleErrCB(\"You need either 'ffmpeg' or 'avconv' and they need to be added to PATH\", callback);\r\n\r\n\tvoiceSession.audio = voiceSession.audio || new AudioCB(\r\n\t\tvoiceSession,\r\n\t\tchannelObj.stereo === false ? 1 : 2,\r\n\t\tencoder,\r\n\t\tMath.abs(Number(channelObj.maxStreamSize)));\r\n\r\n\treturn call(callback, [null, voiceSession.audio]);\r\n};\r\n\r\n/* --- Misc --- */\r\n\r\n/**\r\n * Retrieves all offline (and online, if using a user account) users, fires the `allUsers` event when done.\r\n */\r\nDCP.getAllUsers = function(callback) {\r\n\tvar servers = Object.keys(this.servers).filter(function(s) {\r\n\t\t\ts = this.servers[s];\r\n\t\t\tif (s.members) return s.member_count !== Object.keys(s.members).length && (this.bot ? s.large : true);\r\n\t\t}, this);\r\n\r\n\tif (!servers[0]) {\r\n\t\tthis.emit('allUsers');\r\n\t\treturn handleErrCB(\"There are no users to be collected\", callback);\r\n\t}\r\n\tif (!this.bot) send(this._ws, Payloads.ALL_USERS(this));\r\n\r\n\treturn getOfflineUsers(this, servers, callback);\r\n};\r\n\r\n/* --- Functions --- */\r\nfunction handleErrCB(err, callback) {\r\n\tif (!err) return false;\r\n\treturn call(callback, [new Error(err)]);\r\n}\r\nfunction handleResCB(errMessage, err, res, callback) {\r\n\tif (typeof(callback) !== 'function') return;\r\n\tres = res || {};\r\n\tif (!err && goodResponse(res)) return (callback(null, res.body), true);\r\n\r\n\tvar e = new Error( err || errMessage );\r\n\te.name = \"ResponseError\";\r\n\te.statusCode = res.statusCode;\r\n\te.statusMessage = res.statusMessage;\r\n\te.response = res.body;\r\n\treturn (callback(e), false);\r\n}\r\nfunction goodResponse(response) {\r\n\treturn (response.statusCode / 100 | 0) === 2;\r\n}\r\nfunction stringifyError(response) {\r\n\tif (!response) return null;\r\n\treturn response.statusCode + \" \" + response.statusMessage + \"\\n\" + JSON.stringify(response.body);\r\n}\r\n\r\n/* - Functions - Messages - */\r\nfunction sendMessage(client, to, message, callback) {\r\n\tresolveID(client, to, function(channelID) {\r\n\t\tclient._req('post', Endpoints.MESSAGES(channelID), message, function(err, res) {\r\n\t\t\thandleResCB(\"Unable to send messages\", err, res, callback);\r\n\t\t});\r\n\t});\r\n}\r\nfunction cacheMessage(cache, limit, channelID, message) {\r\n\tif (!cache[channelID]) cache[channelID] = {};\r\n\tif (limit === -1) return void(cache[channelID][message.id] = message);\r\n\tvar k = Object.keys(cache[channelID]);\r\n\tif (k.length > limit) delete(cache[channelID][k[0]]);\r\n\tcache[channelID][message.id] = message;\r\n}\r\nfunction generateMessage(message, embed) {\r\n\treturn {\r\n\t\tcontent: String(message),\r\n\t\tnonce: Math.floor(Math.random() * Number.MAX_SAFE_INTEGER),\r\n\t\tembed: embed || {}\r\n\t};\r\n}\r\nfunction messageHeaders(client) {\r\n\tvar r = {\r\n\t\t\"accept\": \"*/*\",\r\n\t\t\"accept-language\": \"en-US;q=0.8\",\r\n\t};\r\n\tif (isNode) {\r\n\t\tr[\"accept-encoding\"] = \"gzip, deflate\";\r\n\t\tr.user_agent = \"DiscordBot (https://github.com/izy521/discord.io, \" + CURRENT_VERSION + \")\";\r\n\t\tr.dnt = 1;\r\n\t}\r\n\ttry {\r\n\t\tr.authorization = (client.bot ? \"Bot \" : \"\") + client.internals.token;\r\n\t} catch(e) {}\r\n\treturn r;\r\n}\r\nfunction simulateTyping(client, to, message, time, callback) {\r\n\tif (time <= 0) return sendMessage(client, to, message, callback);\r\n\r\n\tclient.simulateTyping(to, function() {\r\n\t\tsetTimeout(simulateTyping, Math.min(time, 5000), client, to, message, time - 5000, callback);\r\n\t});\r\n}\r\nfunction stringifyEmoji(emoji) {\r\n\tif (typeof emoji === 'object') // if (emoji.name && emoji.id)\r\n\t\treturn emoji.name + ':' + emoji.id;\r\n\tif (emoji.indexOf(':') > -1)\r\n\t\treturn emoji;\r\n\treturn encodeURIComponent(decodeURIComponent(emoji));\r\n}\r\n\r\n/* - Functions - Utils */\r\nfunction APIRequest(method, url) {\r\n\tvar data, callback, opts, req, headers = messageHeaders(this);\r\n\tcallback = ( typeof(arguments[2]) === 'function' ? arguments[2] : (data = arguments[2], arguments[3]) );\r\n\r\n\tif (isNode) {\r\n\t\topts = URL.parse(url);\r\n\t\topts.method = method;\r\n\t\topts.headers = headers;\r\n\r\n\t\treq = requesters[opts.protocol.slice(0, -1)].request(opts, function(res) {\r\n\t\t\tvar chunks = [];\r\n\t\t\tres.on('data', function(c) { chunks[chunks.length] = c; });\r\n\t\t\tres.once('end', function() {\r\n\t\t\t\tchunks = Buffer.concat(chunks);\r\n\t\t\t\tZlib.gunzip(chunks, function(err, uc) {\r\n\t\t\t\t\tif (!err) uc = uc.toString();\r\n\t\t\t\t\ttry { res.body = JSON.parse(uc || chunks); } catch(e) {}\r\n\t\t\t\t\treturn callback(null, res);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t});\r\n\t\tif (type(data) === 'object' || method.toLowerCase() === 'get') req.setHeader(\"Content-Type\", \"application/json; charset=utf-8\");\r\n\t\tif (data instanceof Multipart) req.setHeader(\"Content-Type\", \"multipart/form-data; boundary=\" + data.boundary);\r\n\t\tif (data) req.write( data.result || JSON.stringify(data), data.result ? 'binary' : 'utf-8' );\r\n\t\treq.end();\r\n\r\n\t\treturn req.once('error', function(e) { return callback(e.message); });\r\n\t}\r\n\r\n\treq = new XMLHttpRequest();\r\n\treq.open(method.toUpperCase(), url, true);\r\n\tfor (var key in headers) {\r\n\t\treq.setRequestHeader(key, headers[key]);\r\n\t}\r\n\treq.onreadystatechange = function() {\r\n\t\tif (req.readyState == 4) {\r\n\t\t\treq.statusCode = req.status;\r\n\t\t\treq.statusMessage = req.statusText;\r\n\t\t\ttry {req.body = JSON.parse(req.responseText);} catch (e) { return handleErrCB(e, callback); }\r\n\t\t\tcallback(null, req);\r\n\t\t}\r\n\t};\r\n\tif (type(data) === 'object' || method.toLowerCase() === 'get') req.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\");\r\n\tif (data instanceof Multipart) req.setRequestHeader(\"Content-Type\", \"multipart/form-data; boundary=\" + data.boundary);\r\n\tif (data) return req[ (data.result ? \"sendAsBinary\" : \"send\") ]( data.result ? data.result : JSON.stringify(data) );\r\n\treq.send(null);\r\n}\r\nfunction send(ws, data) {\r\n\tif (ws && ws.readyState == 1) ws.send(JSON.stringify(data));\r\n}\r\nfunction copy(obj) {\r\n\ttry {\r\n\t\treturn JSON.parse( JSON.stringify( obj ) );\r\n\t} catch(e) {}\r\n}\r\nfunction copyKeys(from, to, omit) {\r\n\tif (!omit) omit = [];\r\n\tfor (var key in from) {\r\n\t\tif (omit.indexOf(key) > -1) continue;\r\n\t\tto[key] = from[key];\r\n\t}\r\n}\r\nfunction applyProperties(object, properties) {\r\n\tproperties.forEach(function(t) {\r\n\t\tObject.defineProperty(object, t[0], {\r\n\t\t\tconfigurable: true,\r\n\t\t\twritable: true,\r\n\t\t\tvalue: t[1]\r\n\t\t});\r\n\t}, object);\r\n}\r\nfunction type(v) {\r\n\treturn Object.prototype.toString.call(v).match(/ (.*)]/)[1].toLowerCase();\r\n}\r\nfunction call(f, a) {\r\n\tif (typeof(f) != 'function') return;\r\n\treturn f.apply(null, a);\r\n}\r\nfunction qstringify(obj) {\r\n\t//.map + .join is 7x slower!\r\n\tvar i=0, s = \"\", k = Object.keys(obj);\r\n\tfor (i;i<k.length;i++) {\r\n\t\ts += k[i] + \"=\" + obj[k[i]] + \"&\";\r\n\t}\r\n\treturn \"?\" + s.slice(0, -1);\r\n}\r\nfunction emit(client, message) {\r\n\tif (!message.t) return;\r\n\tvar t = message.t.split(\"_\"), i = 1, args = [t[0].toLowerCase()];\r\n\r\n\tfor (i; i<t.length; i++) {\r\n\t\targs[0] += t[i][0] + t[i].slice(1).toLowerCase();\r\n\t}\r\n\tfor (i=2; i<arguments.length; i++) {\r\n\t\targs.push(arguments[i]);\r\n\t}\r\n\targs.push(message);\r\n\tclient.emit.apply(client, args);\r\n}\r\nfunction decompressWSMessage(m, f) {\r\n\tf = f || {};\r\n\treturn f.binary ? JSON.parse(Zlib.inflateSync(m).toString()) : JSON.parse(m);\r\n}\r\nfunction removeAllListeners(emitter, type) {\r\n\tif (!emitter) return;\r\n\tvar e = emitter._evts, i, k, o, s, z;\r\n\tif (isNode) return type ? emitter.removeAllListeners(type) : emitter.removeAllListeners();\r\n\r\n\tif (type && e[type]) {\r\n\t\tfor (i=0; i<e[type].length; i++) {\r\n\t\t\temitter.removeListener(type, e[type][i]);\r\n\t\t}\r\n\t}\r\n\r\n\tif (!type) {\r\n\t\tk = Object.keys(e);\r\n\t\tfor (o=0; o<k.length; o++) {\r\n\t\t\ts = e[ k[o] ];\r\n\t\t\tfor (z=0; z<s.length; z++) {\r\n\t\t\t\temitter.removeListener(k[o], s[z]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nfunction colorFromRole(server, member) {\r\n\treturn member.roles.reduce(function(array, ID) {\r\n\t\tvar role = server.roles[ID];\r\n\t\tif (!role) return array;\r\n\t\treturn role.position > array[0] && role.color ? [role.position, role.color] : array;\r\n\t}, [-1, null])[1];\r\n}\r\n\r\nfunction givePermission(bit, permissions) {\r\n\treturn permissions | (1 << bit);\r\n}\r\nfunction removePermission(bit, permissions) {\r\n\treturn permissions & ~(1 << bit);\r\n}\r\nfunction hasPermission(bit, permissions) {\r\n\treturn ((permissions >> bit) & 1) == 1;\r\n}\r\n//For the Getters and Setters\r\nfunction getPerm(bit) {\r\n\treturn function() {\r\n\t\treturn ((this._permissions >> bit) & 1) == 1;\r\n\t};\r\n}\r\nfunction setPerm(bit) {\r\n\treturn function(v) {\r\n\t\tif (v === true) return this._permissions |= (1 << (bit));\r\n\t\tif (v === false) return this._permissions &= ~(1 << bit);\r\n\t};\r\n}\r\n\r\nfunction getServerInfo(client, servArr) {\r\n\tfor (var server=0; server<servArr.length; server++) {\r\n\t\tclient.servers[servArr[server].id] = new Server(client, servArr[server]);\r\n\t}\r\n}\r\nfunction getDirectMessages(client, DMArray) {\r\n\tfor (var DM=0; DM<DMArray.length; DM++) {\r\n\t\tclient.directMessages[DMArray[DM].id] = new DMChannel(client._uIDToDM, DMArray[DM]);\r\n\t}\r\n}\r\nfunction resolveID(client, ID, callback) {\r\n\t/*Get channel from ServerID, ChannelID or UserID.\r\n\tOnly really used for sendMessage and uploadFile.*/\r\n\t//Callback used instead of return because requesting seems necessary.\r\n\r\n\tif (client._uIDToDM[ID]) return callback(client._uIDToDM[ID]);\r\n\t//If it's a UserID, and it's in the UserID : ChannelID cache, use the found ChannelID\r\n\r\n\t//If the ID isn't in the UserID : ChannelID cache, let's try seeing if it belongs to a user.\r\n\tif (client.users[ID]) return client.createDMChannel(ID, function(err, res) {\r\n\t\tif (err) return console.log(\"Internal ID resolver error: \" + err);\r\n\t\tcallback(res.id);\r\n\t});\r\n\r\n\treturn callback(ID); //Finally, the ID must not belong to a User, so send the message directly to it, as it must be a Channel's.\r\n}\r\nfunction resolveEvent(e) {\r\n\treturn e.detail || ([e.data][0] ? [e.data] : [e.code]);\r\n}\r\n\r\n/* --- Initializing --- */\r\nfunction init(client, opts) {\r\n\tclient.servers = {};\r\n\tclient.channels = {};\r\n\tclient.users = {};\r\n\tclient.directMessages = {};\r\n\tclient.internals = {\r\n\t\toauth: {},\r\n\t\tversion: CURRENT_VERSION,\r\n\t\tsettings: {}\r\n\t};\r\n\tclient._connecting = true;\r\n\r\n\tsetupPing(client.internals);\r\n\treturn getToken(client, opts);\r\n}\r\nfunction getToken(client, opts) {\r\n\tif (opts.token) return getGateway(client, opts.token);\r\n\tif (!isNode) {\r\n\t\t//Read from localStorage? Sounds like a bad idea, but I'll leave this here.\r\n\t}\r\n}\r\nfunction getGateway(client, token) {\r\n\tclient.internals.token = token;\r\n\r\n\treturn APIRequest('get', Endpoints.GATEWAY, function (err, res) {\r\n\t\tif (err || !goodResponse(res)) {\r\n\t\t\tclient._connecting = false;\r\n\t\t\treturn client.emit(\"disconnect\", \"Error GETing gateway:\\n\" + stringifyError(res), 0);\r\n\t\t}\r\n\t\treturn startConnection(client, (res.body.url + \"/?encoding=json&v=\" + GATEWAY_VERSION));\r\n\t});\r\n}\r\nfunction startConnection(client, gateway) {\r\n\tclient._ws = new Websocket(gateway);\r\n\tclient.internals.gatewayUrl = gateway;\r\n\r\n\tclient._ws.once('close', handleWSClose.bind(client));\r\n\tclient._ws.once('error', handleWSClose.bind(client));\r\n\tclient._ws.on('message', handleWSMessage.bind(client));\r\n}\r\nfunction getOfflineUsers(client, servArr, callback) {\r\n\tif (!servArr[0]) return call(callback);\r\n\r\n\tsend(client._ws, Payloads.OFFLINE_USERS(servArr));\r\n\treturn setTimeout( getOfflineUsers, 0, client, servArr, callback );\r\n}\r\nfunction checkForAllServers(client, ready, message) {\r\n\tvar all = Object.keys(client.servers).every(function(s) {\r\n\t\treturn !client.servers[s].unavailable;\r\n\t});\r\n\tif (all || ready[0]) return void(client._ready = true && client.emit('ready', message));\r\n\treturn setTimeout(checkForAllServers, 0, client, ready, message);\r\n}\r\nfunction setupPing(obj) {\r\n\tapplyProperties(obj, [\r\n\t\t[\"_pings\", []],\r\n\t\t[\"_lastHB\", 0]\r\n\t]);\r\n\tObject.defineProperty(obj, 'ping', {\r\n\t\tget: function() {\r\n\t\t\treturn ((obj._pings.reduce(function(p, c) { return p + c; }, 0) / obj._pings.length) || 0) | 0;\r\n\t\t},\r\n\t\tset: function() {}\r\n\t});\r\n}\r\nfunction validateShard(shard) {\r\n\treturn (\r\n\t\ttype(shard)  === 'array' &&\r\n\t\tshard.length === 2       &&\r\n\t\tshard[0] <= shard[1]     &&\r\n\t\tshard[1] > 1\r\n\t) ? shard : null;\r\n}\r\nfunction identifyOrResume(client) {\r\n\tvar payload, internals = client.internals;\r\n\r\n\tif (internals.sequence && internals.token && internals.sessionID) {\r\n\t\tpayload = Payloads.RESUME(client);\r\n\t} else {\r\n\t\tpayload = Payloads.IDENTIFY(client);\r\n\t\tif (client._shard) payload.d.shard = client._shard;\r\n\t}\r\n\tclient._connecting = false;\r\n\r\n\treturn send(client._ws, payload);\r\n}\r\n\r\n/* - Functions - Websocket Handling - */\r\nfunction handleWSMessage(data, flags) {\r\n\tvar message = decompressWSMessage(data, flags);\r\n\tvar _data = message.d;\r\n\tvar client = this, user, server, member, old,\r\n\tuserID, serverID, channelID, currentVCID;\r\n\tclient.internals.sequence = message.s;\r\n\r\n\tswitch (message.op) {\r\n\t\tcase 10:\r\n\t\t\t//Start keep-alive interval\r\n\t\t\t//Disconnect the client if no ping has been received\r\n\t\t\t//in 15 seconds (I think that's a decent duration)\r\n\t\t\t//Since v3 you the IDENTIFY/RESUME payload here.\r\n\t\t\tidentifyOrResume(client);\r\n\t\t\tclient.presenceStatus = 'online';\r\n\t\t\tclient.connected = true;\r\n\r\n\t\t\tclient._mainKeepAlive = setInterval(function() {\r\n\t\t\t\tclient.internals.heartbeat = setTimeout(client._ws.close.bind(client._ws, 1e3, 'No heartbeat received'), 15e3);\r\n\t\t\t\tclient.internals._lastHB = Date.now();\r\n\t\t\t\tsend(client._ws, Payloads.HEARTBEAT(client));\r\n\t\t\t}, _data.heartbeat_interval);\r\n\t\t\tbreak;\r\n\t\tcase 11:\r\n\t\t\tclearTimeout(client.internals.heartbeat);\r\n\t\t\tclient.internals._pings.unshift(Date.now() - client.internals._lastHB);\r\n\t\t\tclient.internals._pings = client.internals._pings.slice(0, 10);\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\t//Events\r\n\tclient.emit('any', message);\r\n\t//TODO: Remove in v3\r\n\tclient.emit('debug', message);\r\n\tswitch (message.t) {\r\n\t\tcase \"READY\":\r\n\t\t\tcopyKeys(_data.user, client);\r\n\t\t\tclient.internals.sessionID = _data.session_id;\r\n\r\n\t\t\tgetServerInfo(client, _data.guilds);\r\n\t\t\tgetDirectMessages(client, _data.private_channels);\r\n\r\n\t\t\tif (client.bot) client.getOauthInfo(function(err, res) {\r\n\t\t\t\tif (err) return console.log(err);\r\n\t\t\t\tclient.internals.oauth = res;\r\n\t\t\t\tclient.inviteURL = \"https://discordapp.com/oauth2/authorize?client_id=\" + res.id + \"&scope=bot\";\r\n\t\t\t});\r\n\t\t\tif (!client.bot) client.getAccountSettings(function(err, res) {\r\n\t\t\t\tif (err) return console.log(err);\r\n\t\t\t\tclient.internals.settings = res;\r\n\t\t\t});\r\n\r\n\t\t\treturn (function() {\r\n\t\t\t\tif (client._ready) return;\r\n\t\t\t\tvar ready = [false];\r\n\t\t\t\tsetTimeout(function() { ready[0] = true; }, 3500);\r\n\t\t\t\tcheckForAllServers(client, ready, message);\r\n\t\t\t})();\r\n\t\tcase \"MESSAGE_CREATE\":\r\n\t\t\tclient.emit('message', _data.author.username, _data.author.id, _data.channel_id, _data.content, message);\r\n\t\t\temit(client, message, _data.author.username, _data.author.id, _data.channel_id, _data.content);\r\n\t\t\treturn cacheMessage(client._messageCache, client._messageCacheLimit, _data.channel_id, _data);\r\n\t\tcase \"MESSAGE_UPDATE\":\r\n\t\t\ttry {\r\n\t\t\t\temit(client, message, client._messageCache[_data.channel_id][_data.id], _data);\r\n\t\t\t} catch (e) { emit(client, message, undefined, _data); }\r\n\t\t\treturn cacheMessage(client._messageCache, client._messageCacheLimit, _data.channel_id, _data);\r\n\t\tcase \"PRESENCE_UPDATE\":\r\n\t\t\tif (!_data.guild_id) break;\r\n\r\n\t\t\tserverID = _data.guild_id;\r\n\t\t\tuserID = _data.user.id;\r\n\r\n\t\t\tif (!client.users[userID]) client.users[userID] = new User(_data.user);\r\n\r\n\t\t\tuser = client.users[userID];\r\n\t\t\tmember = client.servers[serverID].members[userID] || {};\r\n\r\n\t\t\tcopyKeys(_data.user, user);\r\n\t\t\tuser.game = _data.game;\r\n\r\n\t\t\tcopyKeys(_data, member, ['user', 'guild_id', 'game']);\r\n\t\t\tclient.emit('presence', user.username, user.id, member.status, user.game, message);\r\n\t\t\tbreak;\r\n\t\tcase \"USER_UPDATE\":\r\n\t\t\tcopyKeys(_data, client);\r\n\t\t\tbreak;\r\n\t\tcase \"USER_SETTINGS_UPDATE\":\r\n\t\t\tcopyKeys(_data, client.internals);\r\n\t\t\tbreak;\r\n\t\tcase \"GUILD_CREATE\":\r\n\t\t\t/*The lib will attempt to create the server using the response from the\r\n\t\t\tREST API, if the user using the lib creates the server. There are missing keys, however.\r\n\t\t\tSo we still need this GUILD_CREATE event to fill in the blanks.\r\n\t\t\tIf It's not our created server, then there will be no server with that ID in the cache,\r\n\t\t\tSo go ahead and create one.*/\r\n\t\t\tclient.servers[_data.id] = new Server(client, _data);\r\n\t\t\treturn emit(client, message, client.servers[_data.id]);\r\n\t\tcase \"GUILD_UPDATE\":\r\n\t\t\told = copy(client.servers[_data.id]);\r\n\t\t\tServer.update(client, _data);\r\n\t\t\treturn emit(client, message, old, client.servers[_data.id]);\r\n\t\tcase \"GUILD_DELETE\":\r\n\t\t\temit(client, message, client.servers[_data.id]);\r\n\t\t\treturn delete(client.servers[_data.id]);\r\n\t\tcase \"GUILD_MEMBER_ADD\":\r\n\t\t\tclient.users[_data.user.id] = new User(_data.user);\r\n\t\t\tclient.servers[_data.guild_id].members[_data.user.id] = new Member(client, client.servers[_data.guild_id], _data);\r\n\t\t\tclient.servers[_data.guild_id].member_count += 1;\r\n\t\t\treturn emit(client, message, client.servers[_data.guild_id].members[_data.user.id]);\r\n\t\tcase \"GUILD_MEMBER_UPDATE\":\r\n\t\t\told = copy(client.servers[_data.guild_id].members[_data.user.id]);\r\n\t\t\tMember.update(client, client.servers[_data.guild_id], _data);\r\n\t\t\treturn emit(client, message, old, client.servers[_data.guild_id].members[_data.user.id]);\r\n\t\tcase \"GUILD_MEMBER_REMOVE\":\r\n\t\t\tif (_data.user && _data.user.id === client.id) return;\r\n\t\t\tclient.servers[_data.guild_id].member_count -= 1;\r\n\t\t\temit(client, message, client.servers[_data.guild_id].members[_data.user.id]);\r\n\t\t\treturn delete(client.servers[_data.guild_id].members[_data.user.id]);\r\n\t\tcase \"GUILD_ROLE_CREATE\":\r\n\t\t\tclient.servers[_data.guild_id].roles[_data.role.id] = new Role(_data.role);\r\n\t\t\treturn emit(client, message, client.servers[_data.guild_id].roles[_data.role.id]);\r\n\t\tcase \"GUILD_ROLE_UPDATE\":\r\n\t\t\tserver = client.servers[_data.guild_id];\r\n\t\t\told = copy(server.roles[_data.role.id]);\r\n\t\t\tRole.update(server, _data);\r\n\t\t\tObject.keys(server.members).forEach(function(memberID) {\r\n\t\t\t\tvar member = server.members[memberID];\r\n\t\t\t\tif ( member.roles.indexOf(_data.role.id) < 0 ) return;\r\n\t\t\t\tmember.color = colorFromRole(server, member);\r\n\t\t\t});\r\n\t\t\treturn emit(client, message, old, server.roles[_data.role.id]);\r\n\t\tcase \"GUILD_ROLE_DELETE\":\r\n\t\t\temit(client, message, client.servers[_data.guild_id].roles[_data.role_id]);\r\n\t\t\treturn delete(client.servers[_data.guild_id].roles[_data.role_id]);\r\n\t\tcase \"CHANNEL_CREATE\":\r\n\t\t\tchannelID = _data.id;\r\n\r\n\t\t\tif (_data.is_private) {\r\n\t\t\t\tif (client.directMessages[channelID]) return;\r\n\t\t\t\tclient.directMessages[channelID] = new DMChannel(client._uIDToDM, _data);\r\n\t\t\t\treturn emit(client, message, client.directMessages[channelID]);\r\n\t\t\t}\r\n\r\n\t\t\tif (client.channels[channelID]) return;\r\n\t\t\tclient.channels[channelID] = new Channel(client, client.servers[_data.guild_id], _data);\r\n\t\t\treturn emit(client, message, client.channels[channelID]);\r\n\t\tcase \"CHANNEL_UPDATE\":\r\n\t\t\told = copy(client.channels[_data.id]);\r\n\t\t\tChannel.update(client, _data);\r\n\t\t\treturn emit(client, message, old, client.channels[_data.id]);\r\n\t\tcase \"CHANNEL_DELETE\":\r\n\t\t\tif (_data.is_private === true) {\r\n\t\t\t\temit(client, message, client.directMessages[_data.id]);\r\n\t\t\t\tdelete(client.directMessages[_data.id]);\r\n\t\t\t\treturn delete(client._uIDToDM[_data.recipient.id]);\r\n\t\t\t}\r\n\t\t\temit(client, message, client.servers[_data.guild_id].channels[_data.id]);\r\n\t\t\tdelete(client.servers[_data.guild_id].channels[_data.id]);\r\n\t\t\treturn delete(client.channels[_data.id]);\r\n\t\tcase \"GUILD_EMOJIS_UPDATE\":\r\n\t\t\told = copy(client.servers[_data.guild_id].emojis);\r\n\t\t\tEmoji.update(client.servers[_data.guild_id], _data.emojis);\r\n\t\t\treturn emit(client, message, old, client.servers[_data.guild_id].emojis);\r\n\t\tcase \"VOICE_STATE_UPDATE\":\r\n\t\t\tserverID = _data.guild_id;\r\n\t\t\tchannelID = _data.channel_id;\r\n\t\t\tuserID = _data.user_id;\r\n\t\t\tserver = client.servers[serverID];\r\n\r\n\t\t\ttry {\r\n\t\t\t\tcurrentVCID = server.members[userID].voice_channel_id;\r\n\t\t\t\tif (currentVCID) delete( server.channels[currentVCID].members[userID] );\r\n\t\t\t\tif (channelID) server.channels[channelID].members[userID] = _data;\r\n\t\t\t\tserver.members[userID].voice_channel_id = channelID;\r\n\t\t\t} catch(e) {}\r\n\r\n\t\t\tif (userID === client.id) {\r\n\t\t\t\tif (channelID === null) {\r\n\t\t\t\t\tif (server.voiceSession) leaveVoiceChannel(client, server.voiceSession.channelID);\r\n\t\t\t\t\treturn void(server.voiceSession = null);\r\n\t\t\t\t}\r\n\t\t\t\tif (!server.voiceSession) {\r\n\t\t\t\t\tserver.voiceSession = getVoiceSession(client, channelID, server);\r\n\t\t\t\t}\r\n\t\t\t\tif (channelID !== server.voiceSession.channelID) {\r\n\t\t\t\t\tdelete( client._vChannels[server.voiceSession.channelID] );\r\n\t\t\t\t\tgetVoiceSession(client, channelID, server).channelID = channelID;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tserver.voiceSession.session = _data.session_id;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase \"VOICE_SERVER_UPDATE\":\r\n\t\t\tserverID = _data.guild_id;\r\n\t\t\tserver = client.servers[serverID];\r\n\t\t\tserver.voiceSession.token = _data.token;\r\n\t\t\tserver.voiceSession.severID = serverID;\r\n\t\t\tserver.voiceSession.endpoint = _data.endpoint;\r\n\t\t\tjoinVoiceChannel(client, server.voiceSession);\r\n\t\t\tbreak;\r\n\t\tcase \"GUILD_MEMBERS_CHUNK\":\r\n\t\t\tserverID = _data.guild_id;\r\n\t\t\tif (!client.servers[serverID].members) client.servers[serverID].members = {};\r\n\r\n\t\t\t_data.members.forEach(function(member) {\r\n\t\t\t\tvar uID = member.user.id;\r\n\t\t\t\tvar members = client.servers[serverID].members;\r\n\t\t\t\tif (members[uID]) return;\r\n\t\t\t\tif (!client.users[uID]) client.users[uID] = new User(member.user);\r\n\t\t\t\tmembers[uID] = new Member(client, client.servers[serverID], member);\r\n\t\t\t});\r\n\t\t\tvar all = Object.keys(client.servers).every(function(server) {\r\n\t\t\t\tserver = client.servers[server];\r\n\t\t\t\treturn server.member_count === Object.keys(server.members).length;\r\n\t\t\t});\r\n\r\n\t\t\tif (all) return client.emit(\"allUsers\");\r\n\t\t\tbreak;\r\n\t\tcase \"GUILD_SYNC\":\r\n\t\t\t_data.members.forEach(function(member) {\r\n\t\t\t\tvar uID = member.user.id;\r\n\t\t\t\tif (!client.users[uID]) client.users[uID] = new User(member.user);\r\n\t\t\t\tclient.servers[_data.id].members[uID] = new Member(client, client.servers[_data.id], member);\r\n\t\t\t});\r\n\r\n\t\t\t_data.presences.forEach(function(presence) {\r\n\t\t\t\tvar uID = presence.user.id;\r\n\t\t\t\tvar members = client.servers[_data.id].members;\r\n\t\t\t\tif (!members[uID]) return void(new User(presence.user));\r\n\t\t\t\tdelete(presence.user);\r\n\t\t\t\tcopyKeys(presence, members[uID]);\r\n\t\t\t});\r\n\t\t\tclient.servers[_data.id].large = _data.large;\r\n\t\t\tbreak;\r\n\t}\r\n\treturn emit(client, message);\r\n}\r\nfunction handleWSClose(code, data) {\r\n\tvar client = this;\r\n\tvar eMsg = Discord.Codes.WebSocket[code];\r\n\r\n\tclearInterval(client._mainKeepAlive);\r\n\tclient.connected = false;\r\n\tclient.presenceStatus = \"offline\";\r\n\tremoveAllListeners(client._ws, 'message');\r\n\r\n\tif ([1001, 1006].indexOf(code) > -1) return getGateway(client, client.internals.token);\r\n\r\n\tclient._ready = false;\r\n\tclient._ws = null;\r\n\r\n\tclient.emit(\"disconnect\", eMsg, code);\r\n}\r\n\r\n/* - Functions - Voice - */\r\nfunction joinVoiceChannel(client, voiceSession) {\r\n\tvar vWS, vUDP, endpoint = voiceSession.endpoint.split(\":\")[0];\r\n\t//handleVoiceChannelChange(client, voiceSession);\r\n\r\n\tvoiceSession.ws = {};\r\n\tvoiceSession.udp = {};\r\n\tvoiceSession.members = {};\r\n\tvoiceSession.error = null;\r\n\tvoiceSession.ready = false;\r\n\tvoiceSession.joined = false;\r\n\tvoiceSession.translator = {};\r\n\tvoiceSession.wsKeepAlive = null;\r\n\tvoiceSession.udpKeepAlive = null;\r\n\tvoiceSession.keepAlivePackets = 0;\r\n\tvoiceSession.emitter = new Emitter();\r\n\tif (isNode) voiceSession.keepAliveBuffer = new Buffer(8).fill(0);\r\n\tvWS = voiceSession.ws.connection = new Websocket(\"wss://\" + endpoint);\r\n\r\n\tif (isNode) return DNS.lookup(endpoint, function(err, address) {\r\n\t\tif (err) return void(voiceSession.error = err);\r\n\r\n\t\tvoiceSession.address = address;\r\n\t\tvUDP = voiceSession.udp.connection = UDP.createSocket(\"udp4\");\r\n\r\n\t\tvUDP.bind({exclusive: true});\r\n\t\tvUDP.once('message', handleUDPMessage.bind(client, voiceSession));\r\n\r\n\t\tvWS.once('open',  handlevWSOpen.bind(client, voiceSession));\r\n\t\tvWS.on('message', handlevWSMessage.bind(client, voiceSession));\r\n\t\tvWS.once('close', handlevWSClose.bind(client, voiceSession));\r\n\t});\r\n\r\n\tvWS.once('open',  handlevWSOpen.bind(client, voiceSession));\r\n\tvWS.on('message', handlevWSMessage.bind(client, voiceSession));\r\n\tvWS.once('close', handlevWSClose.bind(client, voiceSession));\r\n\treturn void(voiceSession.joined = true);\r\n}\r\n\r\nfunction leaveVoiceChannel(client, channelID, callback) {\r\n\tif (!client._vChannels[channelID]) return;\r\n\r\n\ttry {\r\n\t\tclient._vChannels[channelID].ws.connection.close();\r\n\t\tclient._vChannels[channelID].udp.connection.close();\r\n\t} catch(e) {}\r\n\r\n\tsend(client._ws, Payloads.UPDATE_VOICE(client.channels[channelID].guild_id, null));\r\n\r\n\treturn call(callback, [null]);\r\n}\r\n\r\nfunction keepUDPAlive(VS) {\r\n\tif (!VS.keepAliveBuffer) return;\r\n\r\n\tif (VS.keepAlivePackets > 4294967294) {\r\n\t\tVS.keepAlivePackets = 0;\r\n\t\tVS.keepAliveBuffer.fill(0);\r\n\t}\r\n\tVS.keepAliveBuffer.writeUIntLE(++VS.keepAlivePackets, 0, 6);\r\n\ttry {\r\n\t\treturn VS.udp.connection.send(VS.keepAliveBuffer, 0, VS.keepAliveBuffer.length, VS.ws.port, VS.address);\r\n\t} catch(e) {}\r\n}\r\n\r\nfunction getVoiceSession(client, channelID, server) {\r\n\tif (!channelID) return null;\r\n\treturn client._vChannels[channelID] ?\r\n\t\tclient._vChannels[channelID] :\r\n\t\tclient._vChannels[channelID] = (server && server.voiceSession) || {\r\n\t\t\tserverID: (server && server.id) || null,\r\n\t\t\tchannelID: channelID,\r\n\t\t\ttoken: null,\r\n\t\t\tsession: null,\r\n\t\t\tendpoint: null\r\n\t\t};\r\n}\r\n\r\nfunction checkVoiceReady(voiceSession, callback) {\r\n\treturn setTimeout(function() {\r\n\t\tif (voiceSession.error) return call(callback, [error]);\r\n\t\tif (voiceSession.joined) return call(callback, [null, voiceSession.emitter]);\r\n\t\treturn checkVoiceReady(voiceSession, callback);\r\n\t}, 1);\r\n}\r\n\r\n/* - Functions - Voice - Handling - */\r\n\r\nfunction handlevWSOpen(voiceSession) {\r\n\treturn send(voiceSession.ws.connection, Payloads.VOICE_IDENTIFY(this.id, voiceSession));\r\n}\r\nfunction handlevWSMessage(voiceSession, vMessage, vFlags) {\r\n\tvar client = this, vData = decompressWSMessage(vMessage, vFlags);\r\n\tswitch (vData.op) {\r\n\t\tcase 2: //Ready (Actually means you're READY to initiate the UDP connection)\r\n\t\t\tcopyKeys(vData.d, voiceSession.ws);\r\n\t\t\tvoiceSession.wsKeepAlive = setInterval(send, vData.d.heartbeat_interval, voiceSession.ws.connection, { \"op\": 3, \"d\": null });\r\n\r\n\t\t\tif (!isNode) return;\r\n\r\n\t\t\tvar udpDiscPacket = new Buffer(70);\r\n\t\t\tudpDiscPacket.writeUIntBE(vData.d.ssrc, 0, 4);\r\n\t\t\tvoiceSession.udp.connection.send(\r\n\t\t\t\tudpDiscPacket, 0, udpDiscPacket.length, vData.d.port, voiceSession.address,\r\n\t\t\t\tfunction(err) { if (err) {leaveVoiceChannel(client, voiceSession.channelID); handleErrCB(\"UDP discovery error\", callback); } }\r\n\t\t\t);\r\n\r\n\t\t\tvoiceSession.udpKeepAlive = setInterval(keepUDPAlive, 5000, voiceSession);\r\n\t\t\tbreak;\r\n\t\tcase 4: //Session Discription (Actually means you're ready to send audio... stupid Discord Devs :I)\r\n\t\t\tvoiceSession.selectedMode = vData.d.mode;\r\n\t\t\tvoiceSession.secretKey = vData.d.secret_key;\r\n\t\t\tvoiceSession.joined = true;\r\n\t\t\tvoiceSession.ready = true;\r\n\t\t\tbreak;\r\n\t\tcase 5: //Speaking (At least this isn't confusing!)\r\n\t\t\tvoiceSession.emitter.emit('speaking', vData.d.user_id, vData.d.ssrc, vData.d.speaking);\r\n\t\t\tbreak;\r\n\t}\r\n}\r\nfunction handlevWSClose(voiceSession) {\r\n\t//Emit the disconnect event first\r\n\tvoiceSession.emitter.emit(\"disconnect\", voiceSession.channelID);\r\n\tvoiceSession.emitter = null\r\n\t//Kill encoder and decoders\r\n\tvar audio = voiceSession.audio, members = voiceSession.members;\r\n\tif (audio) {\r\n\t\tif (audio._systemEncoder) audio._systemEncoder.kill();\r\n\t\tif (audio._mixedDecoder) audio._mixedDecoder.destroy();\r\n\t}\r\n\r\n\tObject.keys(members).forEach(function(ID) {\r\n\t\tvar member = members[ID];\r\n\t\tif (member.decoder) member.decoder.destroy();\r\n\t});\r\n\r\n\t//Clear intervals and remove listeners\r\n\tclearInterval(voiceSession.wsKeepAlive);\r\n\tclearInterval(voiceSession.udpKeepAlive);\r\n\tremoveAllListeners(voiceSession.emitter);\r\n\tremoveAllListeners(voiceSession.udp.connection, 'message');\r\n\tremoveAllListeners(voiceSession.ws.connection, 'message');\r\n\r\n\treturn delete(this._vChannels[voiceSession.channelID]);\r\n}\r\n\r\nfunction handleUDPMessage(voiceSession, msg, rinfo) {\r\n\tvar buffArr = JSON.parse(JSON.stringify(msg)).data, client = this, vDiscIP = \"\", vDiscPort;\r\n\tfor (var i=4; i<buffArr.indexOf(0, i); i++) {\r\n\t\tvDiscIP += String.fromCharCode(buffArr[i]);\r\n\t}\r\n\tvDiscPort = msg.readUIntLE(msg.length - 2, 2).toString(10);\r\n\treturn send(voiceSession.ws.connection, Payloads.VOICE_DISCOVERY(vDiscIP, vDiscPort, 'xsalsa20_poly1305'));\r\n}\r\n\r\n/* - Functions - Voice - AudioCallback - */\r\nfunction AudioCB(voiceSession, audioChannels, encoder, maxStreamSize) {\r\n\t//With the addition of the new Stream API, `playAudioFile`, `stopAudioFile` and `send`\r\n\t//will be removed. However they're deprecated for now, hence the code repetition.\r\n\tif (maxStreamSize && !Opus) Opus = require('cjopus');\r\n\tStream.Duplex.call(this);\r\n\tvar ACBI = this;\r\n\r\n\tthis.audioChannels = audioChannels;\r\n\tthis.members = voiceSession.members;\r\n\r\n\tapplyProperties(this, [\r\n\t\t[\"_sequence\", 0],\r\n\t\t[\"_timestamp\", 0],\r\n\t\t[\"_readable\", false],\r\n\t\t[\"_streamRef\", null],\r\n\t\t[\"_startTime\", null],\r\n\t\t[\"_systemEncoder\", null],\r\n\t\t[\"_playingAudioFile\", false],\r\n\t\t[\"_voiceSession\", voiceSession],\r\n\t\t[\"_port\", voiceSession.ws.port],\r\n\t\t[\"_address\", voiceSession.address],\r\n\t\t[\"_decodeNonce\", new Uint8Array(24)],\r\n\t\t[\"_vUDP\", voiceSession.udp.connection],\r\n\t\t[\"_secretKey\", new Uint8Array(voiceSession.secretKey)],\r\n\t\t[\"_mixedDecoder\", Opus && new Opus.OpusEncoder( 48000, audioChannels ) || null]\r\n\t]);\r\n\t\r\n\tcreateAudioEncoder(this, encoder);\r\n\r\n\tthis._write = function _write(chunk, encoding, callback) {\r\n\t\tACBI._systemEncoder.stdin.write(chunk);\r\n\t\treturn callback();\r\n\t};\r\n\tthis._read = function _read() {};\r\n\tthis.stop = function stop() {\r\n\t\treturn this._systemEncoder.stdout.read = function() { return null };\r\n\t};\r\n\r\n\tif (maxStreamSize) {\r\n\t\tvoiceSession.ws.connection.on('message', function(data, flags) {\r\n\t\t\tdata = decompressWSMessage(data, flags);\r\n\r\n\t\t\tif (data.op !== 5) return;\r\n\t\t\tif (!voiceSession.members[data.d.user_id]) {\r\n\t\t\t\tvoiceSession.members[data.d.user_id] = new Stream.Readable({\r\n\t\t\t\t\thighWaterMark: maxStreamSize,\r\n\t\t\t\t\tread: function(s) {}\r\n\t\t\t\t});\r\n\t\t\t\tvoiceSession.members[data.d.user_id].decoder = new Opus.OpusEncoder( 48000, ACBI.audioChannels );\r\n\t\t\t\tACBI.emit('newMemberStream', data.d.user_id, voiceSession.members[data.d.user_id]);\r\n\t\t\t}\r\n\r\n\t\t\tvoiceSession.members[data.d.user_id].ssrc = data.d.ssrc;\r\n\t\t\tvoiceSession.translator[data.d.ssrc] = voiceSession.members[data.d.user_id];\r\n\t\t});\r\n\t\tthis._vUDP.on('message', handleIncomingAudio.bind(this));\r\n\t}\r\n}\r\nif (isNode) Util.inherits(AudioCB, Stream.Duplex);\r\nAudioCB.VoicePacket = (function() {\r\n\tif (!isNode) return;\r\n\tvar header = new Buffer(12), nonce = new Uint8Array(24), output = new Buffer(2048);\r\n\r\n\theader[0] = 0x80;\r\n\theader[1] = 0x78;\r\n\r\n\treturn function(packet, ssrc, sequence, timestamp, key) {\r\n\t\theader.writeUIntBE(sequence, 2, 2);\r\n\t\theader.writeUIntBE(timestamp, 4, 4);\r\n\t\theader.writeUIntBE(ssrc, 8, 4);\r\n\t\t//<Buffer 80 78 00 01 00 00 03 c0 00 00 00 01>\r\n\t\tnonce.set(header);\r\n\t\t//<Buffer 80 78 00 01 00 00 03 c0 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 00>\r\n\r\n\t\tvar encrypted = new Buffer(\r\n\t\t\tNACL.secretbox(\r\n\t\t\t\tnew Uint8Array(packet),\r\n\t\t\t\tnonce,\r\n\t\t\t\tkey\r\n\t\t\t)\r\n\t\t);\r\n\r\n\t\theader.copy(output);\r\n\t\tencrypted.copy(output, 12);\r\n\r\n\t\treturn output.slice(0, header.length + encrypted.length);\r\n\t};\r\n})();\r\nvar ACBP = AudioCB.prototype;\r\n//TODO: Remove in v3\r\nACBP.playAudioFile = function(location, callback) {\r\n\tif (!this._mixedDecoder) {\r\n\t\tif (!Opus) Opus = require('cjopus');\r\n\t\tthis._mixedDecoder = new Opus.OpusEncoder( 48000, this.audioChannels );\r\n\t}\r\n\r\n\tif (this._playingAudioFile) return handleErrCB(\"There is already a file being played.\", callback);\r\n\tvar encs = ['ffmpeg', 'avconv'], selection, enc, ACBI = this;\r\n\r\n\tthis._playingAudioFile = true;\r\n\tselection = chooseAudioEncoder(encs);\r\n\r\n\tif (!selection) return console.log(\"You need either 'ffmpeg' or 'avconv' and they need to be added to PATH\");\r\n\r\n\tenc = ChildProc.spawn(selection , [\r\n\t\t'-i', location,\r\n\t\t'-f', 's16le',\r\n\t\t'-ar', '48000',\r\n\t\t'-ac', ACBI.audioChannels,\r\n\t\t'pipe:1'\r\n\t], {stdio: ['pipe', 'pipe', 'ignore']});\r\n\tenc.stdout.once('end', function() {\r\n\t\tenc.kill();\r\n\t\tsend(ACBI._voiceSession.ws.connection, Payloads.VOICE_SPEAK(0));\r\n\t\tACBI._playingAudioFile = false;\r\n\t\tACBI.emit('fileEnd');\r\n\t});\r\n\tenc.stdout.once('error', function(e) {\r\n\t\tenc.stdout.emit('end');\r\n\t});\r\n\tenc.stdout.once('readable', function() {\r\n\t\tsend(ACBI._voiceSession.ws.connection, Payloads.VOICE_SPEAK(1));\r\n\t\tACBI._startTime = new Date().getTime();\r\n\t\tprepareAudioOld(ACBI, enc.stdout, 1);\r\n\t});\r\n\tthis._streamRef = enc;\r\n};\r\n//TODO: Remove in v3\r\nACBP.stopAudioFile = function(callback) {\r\n\tif (!this._playingAudioFile) return handleErrCB(\"There is no file being played\", callback);\r\n\r\n\tthis._streamRef.stdout.end();\r\n\tthis._streamRef.kill();\r\n\tthis._playingAudioFile = false;\r\n\r\n\tcall(callback);\r\n};\r\n//TODO: Remove in v3\r\nACBP.send = function(stream) {\r\n\tif (!this._mixedDecoder) {\r\n\t\tif (!Opus) Opus = require('cjopus');\r\n\t\tthis._mixedDecoder = new Opus.OpusEncoder( 48000, this.audioChannels );\r\n\t}\r\n\tsend(this._voiceSession.ws.connection, Payloads.VOICE_SPEAK(1));\r\n\tthis._startTime = new Date().getTime();\r\n\tprepareAudioOld(this, stream, 1);\r\n};\r\n\r\nfunction prepareAudio(ACBI, readableStream, cnt) {\r\n\tvar data = readableStream.read( 320 ) || readableStream.read(); //(128 [kb] * 20 [frame_size]) / 8 == 320\r\n\r\n\tif (!data) {\r\n\t\tsend(ACBI._voiceSession.ws.connection, Payloads.VOICE_SPEAK(0));\r\n\t\tACBI._readable = false;\r\n\t\treturn readableStream.emit('end');\r\n\t}\r\n\r\n\treturn setTimeout(function() {\r\n\t\tsendAudio(ACBI, data);\r\n\t\tprepareAudio(ACBI, readableStream, cnt + 1);\r\n\t}, 20 + ( (ACBI._startTime + cnt * 20) - Date.now() ));\r\n}\r\n\r\n//TODO: Remove in v3\r\nfunction prepareAudioOld(ACBI, readableStream) {\r\n\tvar done = false;\r\n\r\n\treadableStream.on('end', function() {\r\n\t\tdone = true;\r\n\t\tsend(ACBI._voiceSession.ws.connection, Payloads.VOICE_SPEAK(0));\r\n\t});\r\n\r\n\t_prepareAudio(ACBI, readableStream, 1);\r\n\r\n\tfunction _prepareAudio(ACBI, readableStream, cnt) {\r\n\t\tif (done) return;\r\n\t\tvar buffer, encoded;\r\n\r\n\t\tbuffer = readableStream.read( 1920 * ACBI.audioChannels );\r\n\t\tencoded = [0xF8, 0xFF, 0xFE];\r\n\r\n\t\tif ((buffer && buffer.length === 1920 * ACBI.audioChannels) && !ACBI._mixedDecoder.destroyed) {\r\n\t\t\tencoded = ACBI._mixedDecoder.encode(buffer);\r\n\t\t}\r\n\r\n\t\treturn setTimeout(function() {\r\n\t\t\tsendAudio(ACBI, encoded);\r\n\t\t\t_prepareAudio(ACBI, readableStream, cnt + 1);\r\n\t\t}, 20 + ( (ACBI._startTime + cnt * 20) - Date.now() ));\r\n\t}\r\n}\r\n\r\nfunction sendAudio(ACBI, buffer) {\r\n\tACBI._sequence  = (ACBI._sequence  + 1  ) < 0xFFFF     ? ACBI._sequence  + 1   : 0;\r\n\tACBI._timestamp = (ACBI._timestamp + 960) < 0xFFFFFFFF ? ACBI._timestamp + 960 : 0;\r\n\tvar audioPacket = AudioCB.VoicePacket(buffer, ACBI._voiceSession.ws.ssrc, ACBI._sequence, ACBI._timestamp, ACBI._secretKey);\r\n\r\n\ttry {\r\n\t\t//It throws a synchronous error if it fails (someone leaves the audio channel while playing audio)\r\n\t\tACBI._vUDP.send(audioPacket, 0, audioPacket.length, ACBI._port, ACBI._address);\r\n\t} catch(e) { return; }\r\n}\r\n\r\nfunction handleIncomingAudio(msg) {\r\n\t//The response from the UDP keep alive ping\r\n\tif (msg.length === 8) return;\r\n\r\n\tvar header = msg.slice(0, 12),\r\n\t\taudio = msg.slice(12),\r\n\t\tssrc = header.readUIntBE(8, 4),\r\n\t\tmember = this._voiceSession.translator[ssrc],\r\n\t\tdecrypted, decoded;\r\n\r\n\t\tthis._decodeNonce.set(header);\r\n\r\n\t\ttry {\r\n\t\t\tdecrypted = new Buffer(\r\n\t\t\t\tNACL.secretbox.open(\r\n\t\t\t\t\tnew Uint8Array(audio),\r\n\t\t\t\t\tthis._decodeNonce,\r\n\t\t\t\t\tthis._secretKey\r\n\t\t\t\t)\r\n\t\t\t);\r\n\r\n\t\t\tif (member) {\r\n\t\t\t\tdecoded = member.decoder.decode(decrypted);\r\n\t\t\t\taddToStreamBuffer(member, decoded);\r\n\t\t\t} else {\r\n\t\t\t\tdecoded = this._mixedDecoder.decode(decrypted);\r\n\t\t\t}\r\n\r\n\t\t\taddToStreamBuffer(this, decoded);\r\n\t\t\tthis.emit('incoming', ssrc, decoded );\r\n\t\t} catch(e) {}\r\n}\r\nfunction addToStreamBuffer(RStream, data) {\r\n\treturn RStream.push(new Buffer(data)) || !!RStream.read(data.length);\r\n}\r\n\r\nfunction chooseAudioEncoder(players) {\r\n\tif (!players[0]) return null;\r\n\tvar s = ChildProc.spawnSync(players.shift());\r\n\treturn s.error ? chooseAudioEncoder(players) : s.file;\r\n}\r\nfunction createAudioEncoder(ACBI, encoder) {\r\n\tvar enc = ACBI._systemEncoder;\r\n\tif (enc) {\r\n\t\tenc.stdout.emit('end');\r\n\t\tenc.kill();\r\n\t\tACBI._systemEncoder = null;\r\n\t}\r\n\r\n\tenc = ACBI._systemEncoder = ChildProc.spawn(encoder, [\r\n\t\t'-hide_banner',\r\n\t\t'-loglevel', 'error',\r\n\t\t'-i', 'pipe:0',\r\n\t\t'-map', '0:a',\r\n\t\t'-acodec', 'libopus',\r\n\t\t'-f', 'data',\r\n\t\t'-sample_fmt', 's16',\r\n\t\t'-vbr', 'off',\r\n\t\t'-compression_level', '10',\r\n\t\t'-ar', '48000',\r\n\t\t'-ac', ACBI.audioChannels,\r\n\t\t'-b:a', '128000',\r\n\t\t'pipe:1'\r\n\t], {stdio: ['pipe', 'pipe', 'pipe']});\r\n\r\n\tenc.stderr.once('data', function(d) {\r\n\t\tif (ACBI.listeners('error').length > 0) ACBI.emit('error', d.toString());\r\n\t});\r\n\r\n\tenc.stdin.once('error', function(e) {\r\n\t\tenc.stdout.emit('end');\r\n\t\tenc.kill();\r\n\t});\r\n\r\n\tenc.stdout.once('error', function(e) {\r\n\t\tenc.stdout.emit('end');\r\n\t\tenc.kill();\r\n\t});\r\n\tenc.stdout.once('end', function() {\r\n\t\tcreateAudioEncoder(ACBI, encoder);\r\n\t\tACBI.emit('done');\r\n\t});\r\n\tenc.stdout.on('readable', function() {\r\n\t\tif (ACBI._readable) return;\r\n\r\n\t\tACBI._readable = true;\r\n\t\tsend(ACBI._voiceSession.ws.connection, Payloads.VOICE_SPEAK(1));\r\n\t\tACBI._startTime = new Date().getTime();\r\n\t\tprepareAudio(ACBI, enc.stdout, 1);\r\n\t});\r\n}\r\n\r\n/* - DiscordClient - Classes - */\r\nfunction Resource() {}\r\nObject.defineProperty(Resource.prototype, \"creationTime\", {\r\n\tget: function() { return (+this.id / 4194304) + 1420070400000; },\r\n\tset: function(v) { return; }\r\n});\r\n[Server, Channel, DMChannel, User, Member, Role].forEach(function(p) {\r\n\tp.prototype = Object.create(Resource.prototype);\r\n\tObject.defineProperty(p.prototype, 'constructor', {value: p, enumerable: false});\r\n});\r\n\r\nfunction Server(client, data) {\r\n\tvar server = this;\r\n\t//Accept everything now and trim what we don't need, manually. Any data left in is fine, any data left out could lead to a broken lib.\r\n\tcopyKeys(data, this);\r\n\tthis.large = this.large || this.member_count > LARGE_THRESHOLD;\r\n\tthis.voiceSession = null;\r\n\tif (data.unavailable) return;\r\n\r\n\t//Objects so we can use direct property accessing without for loops\r\n\tthis.channels = {};\r\n\tthis.members = {};\r\n\tthis.roles = {};\r\n\tthis.emojis = {};\r\n\r\n\t//Copy the data into the objects using IDs as keys\r\n\tdata.channels.forEach(function(channel) {\r\n\t\tclient.channels[channel.id] = new Channel(client, server, channel);\r\n\t});\r\n\tdata.roles.forEach(function(role) {\r\n\t\tserver.roles[role.id] = new Role(role);\r\n\t});\r\n\tdata.members.forEach(function(member) {\r\n\t\tclient.users[member.user.id] = new User(member.user);\r\n\t\tserver.members[member.user.id] = new Member(client, server, member);\r\n\t});\r\n\tdata.presences.forEach(function(presence) {\r\n\t\tvar id = presence.user.id;\r\n\t\tif (!client.users[id] || !server.members[id]) return;\r\n\t\tdelete(presence.user);\r\n\r\n\t\tclient.users[id].game = presence.game;\r\n\t\tserver.members[id].status = presence.status;\r\n\t});\r\n\tdata.emojis.forEach(function(emoji) {\r\n\t\tserver.emojis[emoji.id] = new Emoji(emoji);\r\n\t});\r\n\tdata.voice_states.forEach(function(vs) {\r\n\t\tvar cID = vs.channel_id;\r\n\t\tvar uID = vs.user_id;\r\n\t\tif (!server.channels[cID] || !server.members[uID]) return;\r\n\t\tserver.channels[cID].members[uID] = vs;\r\n\t\tserver.members[uID].voice_channel_id = cID;\r\n\t});\r\n\r\n\t//Now we can get rid of any of the things we don't need anymore\r\n\tdelete(this.voice_states);\r\n\tdelete(this.presences);\r\n}\r\nfunction Channel(client, server, data) {\r\n\tvar channel = this;\r\n\tthis.members = {};\r\n\tthis.permissions = { user: {}, role: {} };\r\n\tthis.guild_id = server.id;\r\n\tcopyKeys(data, this, ['permission_overwrites', 'emojis']);\r\n\tObject.defineProperty(server.channels, channel.id, {\r\n\t\tget: function() { return client.channels[channel.id]; },\r\n\t\tset: function(v) { client.channels[channel.id] = v; },\r\n\t\tenumerable: true,\r\n\t\tconfigurable: true\r\n\t});\r\n\tdata.permission_overwrites.forEach(function(p) {\r\n\t\tvar type = (p.type === 'member' ? 'user' : 'role');\r\n\t\tthis.permissions[type][p.id] = {allow: p.allow, deny: p.deny};\r\n\t}, this);\r\n\r\n\r\n\tdelete(this.is_private);\r\n}\r\nfunction DMChannel(translator, data) {\r\n\tcopyKeys(data, this);\r\n\ttranslator[data.recipient.id] = data.id;\r\n\tdelete(this.is_private);\r\n}\r\nfunction User(data) {\r\n\tcopyKeys(data, this);\r\n\tthis.bot = this.bot || false;\r\n}\r\nfunction Member(client, server, data) {\r\n\tcopyKeys(data, this, ['user', 'joined_at',]);\r\n\tthis.id = data.user.id;\r\n\tthis.joined_at = Date.parse(data.joined_at);\r\n\tthis.color = colorFromRole(server, this);\r\n\t['username', 'discriminator', 'bot', 'avatar', 'game'].forEach(function(k) {\r\n\t\tif (k in Member.prototype) return;\r\n\r\n\t\tObject.defineProperty(Member.prototype, k, {\r\n\t\t\tget: function() { return client.users[this.id][k]; },\r\n\t\t\tset: function(v) { client.users[this.id][k] = v; },\r\n\t\t\tenumerable: true,\r\n\t\t});\r\n\t});\r\n}\r\nfunction Role(data) {\r\n\tcopyKeys(data, this, ['permissions']);\r\n\t//Use `permissions` from Discord, or `_permissions` if we're making it out of a cache.\r\n\tthis._permissions = data._permissions || data.permissions;\r\n}\r\nfunction Emoji(data) {\r\n\tcopyKeys(data, this);\r\n}\r\n\r\nfunction Multipart() {\r\n\tthis.boundary =\r\n\t\t\"NodeDiscordIO\" + \"-\" + CURRENT_VERSION;\r\n\tthis.result = \"\";\r\n}\r\nMultipart.prototype.append = function(data) {\r\n\t/* Header */\r\n\tvar str = \"\\r\\n--\";\r\n\tstr += this.boundary + \"\\r\\n\";\r\n\tstr += 'Content-Disposition: form-data; name=\"' + data[0] + '\"';\r\n\tif (data[2]) {\r\n\t\tstr += '; filename=\"' + data[2] + '\"\\r\\n';\r\n\t\tstr += 'Content-Type: application/octet-stream';\r\n\t}\r\n\t/* Body */\r\n\tstr += \"\\r\\n\\r\\n\" + ( data[1] instanceof Buffer ? data[1] : new Buffer(String(data[1]), 'utf-8') ).toString('binary');\r\n\tthis.result += str;\r\n};\r\nMultipart.prototype.finalize = function() {\r\n\tthis.result += \"\\r\\n--\" + this.boundary + \"--\";\r\n};\r\n\r\nServer.update = function(client, data) {\r\n\tif (!client.servers[data.id]) client.servers[data.id] = {}; // new Server(client, data)?\r\n\tfor (var key in data) {\r\n\t\tif (key === 'roles') {\r\n\t\t\tdata[key].forEach(function(r) {\r\n\t\t\t\tclient.servers[data.id].roles[r.id] = new Role(r);\r\n\t\t\t});\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (key === 'emojis') continue;\r\n\t\tclient.servers[data.id][key] = data[key];\r\n\t}\r\n};\r\nChannel.update = function(client, data) {\r\n\tif (!client.channels[data.id]) client.channels[data.id] = {}; // new Channel(client, data)?\r\n\tfor (var key in data) {\r\n\t\tif (key === 'permission_overwrites') {\r\n\t\t\tdata[key].forEach(function(p) {\r\n\t\t\t\tvar type = (p.type === 'member' ? 'user' : 'role');\r\n\t\t\t\tclient.channels[data.id].permissions[type][p.id] = {\r\n\t\t\t\t\tallow: p.allow,\r\n\t\t\t\t\tdeny: p.deny\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tclient.channels[data.id][key] = data[key];\r\n\t}\r\n\tdelete(client.channels[data.id].is_private);\r\n};\r\nMember.update = function(client, server, data) {\r\n\tif (!server.members[data.user.id]) return server.members[data.user.id] = new Member(client, server, data);\r\n\tvar member = server.members[data.user.id];\r\n\tcopyKeys(data, member, ['user']);\r\n\tmember.color = colorFromRole(server, member);\r\n};\r\nRole.update = function(server, data) {\r\n\tif (!server.roles[data.role.id]) server.roles[data.role.id] = {}; // new Role(data)?\r\n\tserver.roles[data.role.id]._permissions = data.role.permissions;\r\n\tcopyKeys(data.role, server.roles[data.role.id], ['permissions']);\r\n};\r\nEmoji.update = function(server, data) {\r\n\tserver.emojis = {};\r\n\tdata.forEach(function(emoji) {\r\n\t\tserver.emojis[emoji.id] = new Emoji(emoji);\r\n\t});\r\n}\r\n\r\nObject.defineProperty(Role.prototype, \"permission_values\", {\r\n\tget: function() { return this; },\r\n\tset: function(v) {},\r\n\tenumerable: true\r\n});\r\n\r\n//Discord.OAuth;\r\nDiscord.version = CURRENT_VERSION;\r\nDiscord.Emitter = Emitter;\r\nDiscord.Codes = {};\r\nDiscord.Codes.WebSocket = {\r\n\t\"0\"   : \"Gateway Error\",\r\n\t\"4000\": \"Unknown Error\",\r\n\t\"4001\": \"Unknown Opcode\",\r\n\t\"4002\": \"Decode Error\",\r\n\t\"4003\": \"Not Authenticated\",\r\n\t\"4004\": \"Authentication Failed\",\r\n\t\"4005\": \"Already Authenticated\",\r\n\t\"4006\": \"Session Not Valid\",\r\n\t\"4007\": \"Invalid Sequence Number\",\r\n\t\"4008\": \"Rate Limited\",\r\n\t\"4009\": \"Session Timeout\",\r\n\t\"4010\": \"Invalid Shard\"\r\n};\r\nDiscord.Colors = {\r\n\tDEFAULT: 0,\r\n\tAQUA: 1752220,\r\n\tGREEN: 3066993,\r\n\tBLUE: 3447003,\r\n\tPURPLE: 10181046,\r\n\tGOLD: 15844367,\r\n\tORANGE: 15105570,\r\n\tRED: 15158332,\r\n\tGREY: 9807270,\r\n\tDARKER_GREY: 8359053,\r\n\tNAVY: 3426654,\r\n\tDARK_AQUA: 1146986,\r\n\tDARK_GREEN: 2067276,\r\n\tDARK_BLUE: 2123412,\r\n\tDARK_PURPLE: 7419530,\r\n\tDARK_GOLD: 12745742,\r\n\tDARK_ORANGE: 11027200,\r\n\tDARK_RED: 10038562,\r\n\tDARK_GREY: 9936031,\r\n\tLIGHT_GREY: 12370112,\r\n\tDARK_NAVY: 2899536\r\n};\r\nDiscord.Permissions = {\r\n\tGENERAL_CREATE_INSTANT_INVITE: 0,\r\n\tGENERAL_KICK_MEMBERS: 1,\r\n\tGENERAL_BAN_MEMBERS: 2,\r\n\tGENERAL_ADMINISTRATOR: 3,\r\n\tGENERAL_MANAGE_CHANNELS: 4,\r\n\tGENERAL_MANAGE_GUILD: 5,\r\n\tGENERAL_MANAGE_ROLES: 28,\r\n\tGENERAL_MANAGE_NICKNAMES: 27,\r\n\tGENERAL_CHANGE_NICKNAME: 26,\r\n\tGENERAL_MANAGE_WEBHOOKS: 29,\r\n\tGENERAL_MANAGE_EMOJIS: 30,\r\n\r\n\tTEXT_ADD_REACTIONS: 6,\r\n\tTEXT_READ_MESSAGES: 10,\r\n\tTEXT_SEND_MESSAGES: 11,\r\n\tTEXT_SEND_TTS_MESSAGE: 12,\r\n\tTEXT_MANAGE_MESSAGES: 13,\r\n\tTEXT_EMBED_LINKS: 14,\r\n\tTEXT_ATTACH_FILES: 15,\r\n\tTEXT_READ_MESSAGE_HISTORY: 16,\r\n\tTEXT_MENTION_EVERYONE: 17,\r\n\tTEXT_EXTERNAL_EMOJIS: 18,\r\n\r\n\tVOICE_CONNECT: 20,\r\n\tVOICE_SPEAK: 21,\r\n\tVOICE_MUTE_MEMBERS: 22,\r\n\tVOICE_DEAFEN_MEMBERS: 23,\r\n\tVOICE_MOVE_MEMBERS: 24,\r\n\tVOICE_USE_VAD: 25,\r\n};\r\n\r\nObject.keys(Discord.Permissions).forEach(function(pn) {\r\n\tObject.defineProperty(Role.prototype, pn, {\r\n\t\tget: getPerm( Discord.Permissions[pn] ),\r\n\t\tset: setPerm( Discord.Permissions[pn] ),\r\n\t\tenumerable: true\r\n\t});\r\n});\r\n\r\n/* Wrappers */\r\nfunction Emitter() {\r\n\tvar emt = this;\r\n\tif (isNode) {\r\n\t\tEE.call(this);\r\n\t\tif (this.prototype) return Util.inherits(this, EE);\r\n\t\treturn new EE();\r\n\t}\r\n\t//Thank you, http://stackoverflow.com/a/24216547\r\n\tfunction _Emitter() {\r\n\t\tvar eventTarget = document.createDocumentFragment();\r\n\t\t[\"addEventListener\", \"dispatchEvent\", \"removeEventListener\"].forEach(function(method) {\r\n\t\t\tif (!this[method]) this[method] = eventTarget[method].bind(eventTarget);\r\n\t\t}, this);\r\n\t}\r\n\t//But I did the rest myself! D:<\r\n\t_Emitter.call(this);\r\n\tthis._evts = {};\r\n\tthis.on = function(eName, eFunc) {\r\n\t\tif (!emt._evts[eName]) emt._evts[eName] = [];\r\n\t\temt._evts[eName].push(eOn);\r\n\r\n\t\treturn this.addEventListener(eName, eOn);\r\n\r\n\t\tfunction eOn(e) {\r\n\t\t\treturn eFunc.apply(null, resolveEvent(e));\r\n\t\t}\r\n\t};\r\n\tthis.once = function(eName, eFunc) {\r\n\t\tif (!emt._evts[eName]) emt._evts[eName] = [];\r\n\t\temt._evts[eName].push(eOnce);\r\n\r\n\t\treturn this.addEventListener(eName, eOnce);\r\n\r\n\t\tfunction eOnce(e) {\r\n\t\t\teFunc.apply(null, resolveEvent(e));\r\n\t\t\treturn emt.removeListener(eName, eOnce);\r\n\t\t}\r\n\t};\r\n\tthis.removeListener = function(eName, eFunc) {\r\n\t\tif (emt._evts[eName]) emt._evts[eName].splice(emt._evts[eName].lastIndexOf(eFunc), 1);\r\n\t\treturn this.removeEventListener(eName, eFunc);\r\n\t};\r\n\tthis.emit = function(eName) {\r\n\t\treturn this.dispatchEvent( new CustomEvent(eName, {'detail': Array.prototype.slice.call(arguments, 1) }) );\r\n\t};\r\n\treturn this;\r\n}\r\n\r\nfunction Websocket(url, opts) {\r\n\tif (isNode) return new (require('ws'))(url, opts);\r\n\treturn Emitter.call(new WebSocket(url));\r\n}\r\n\r\n/* Endpoints */\r\n(function () {\r\n\tvar API = \"https://discordapp.com/api\";\r\n\tvar ME  = API + \"/users/@me\";\r\n\tEndpoints = Discord.Endpoints = {\r\n\t\tAPI: \t\tAPI,\r\n\r\n\t\tME:\t\t\tME,\r\n\t\tNOTE:\t\tfunction(userID) {\r\n\t\t\treturn  ME + \"/notes/\" + userID;\r\n\t\t},\r\n\t\tLOGIN:\t\tAPI + \"/auth/login\",\r\n\t\tOAUTH:\t\tAPI + \"/oauth2/applications/@me\",\r\n\t\tGATEWAY:\tAPI + \"/gateway\",\r\n\t\tSETTINGS: \tME + \"/settings\",\r\n\r\n\t\tSERVERS: function(serverID) {\r\n\t\t\treturn  API + \"/guilds\" + (serverID ? \"/\" + serverID : \"\");\r\n\t\t},\r\n\t\tSERVERS_PERSONAL: function(serverID) {\r\n\t\t\treturn  this.ME + \"/guilds\" + (serverID ? \"/\" + serverID : \"\"); //Method to list personal servers?\r\n\t\t},\r\n\t\tSERVER_EMOJIS: function(serverID, emojiID) {\r\n\t\t\treturn  this.SERVERS(serverID) + \"/emojis\" + (emojiID ? \"/\" + emojiID : \"\");\r\n\t\t},\r\n\r\n\t\tCHANNEL: function(channelID) {\r\n\t\t\treturn  API + \"/channels/\" + channelID;\r\n\t\t},\r\n\r\n\t\tMEMBERS: function(serverID, userID) {\r\n\t\t\treturn  this.SERVERS(serverID) + \"/members\" + (userID ? \"/\" + userID : \"\");\r\n\t\t},\r\n\t\tMEMBER_ROLES: function(serverID, userID, roleID) {\r\n\t\t\treturn\tthis.MEMBERS(serverID, userID) + \"/roles\" + (roleID ? \"/\" + roleID : \"\");\r\n\t\t},\r\n\r\n\t\tUSER: function(userID) {\r\n\t\t\treturn  API + \"/users/\" + userID;\r\n\t\t},\r\n\r\n\t\tROLES: function(serverID, roleID) {\r\n\t\t\treturn  this.SERVERS(serverID) + \"/roles\" + (roleID ? \"/\" + roleID : \"\");\r\n\t\t},\r\n\r\n\t\tBANS: function(serverID, userID) {\r\n\t\t\treturn  this.SERVERS(serverID) + \"/bans\" + (userID ? \"/\" + userID : \"\");\r\n\t\t},\r\n\r\n\t\tMESSAGES: function(channelID, messageID) {\r\n\t\t\treturn  this.CHANNEL(channelID) + \"/messages\" + (messageID ? \"/\" + messageID : \"\");\r\n\t\t},\r\n\t\tPINNED_MESSAGES: function(channelID, messageID) {\r\n\t\t\treturn  this.CHANNEL(channelID) + \"/pins\" + (messageID ? \"/\" + messageID : \"\");\r\n\t\t},\r\n\r\n\t\tMESSAGE_REACTIONS: function(channelID, messageID, reaction) {\r\n\t\t\treturn  this.MESSAGES(channelID, messageID) + \"/reactions\" + ( reaction ? (\"/\" + reaction) : \"\" );\r\n\t\t},\r\n\t\tUSER_REACTIONS: function(channelID, messageID, reaction, userID) {\r\n\t\t  \treturn  this.MESSAGE_REACTIONS(channelID, messageID, reaction) + '/' + ( (!userID || userID === this.id) ? '@me' : userID );\r\n\t\t},\r\n\r\n\t\tINVITES: function(inviteCode) {\r\n\t\t\treturn  API + \"/invite/\" + inviteCode;\r\n\t\t},\r\n\r\n\t\tSERVER_WEBHOOKS: function(serverID) {\r\n\t\t\treturn  this.SERVERS(serverID) + \"/webhooks\";\r\n\t\t},\r\n\t\tCHANNEL_WEBHOOKS: function(channelID) {\r\n\t\t\treturn  this.CHANNEL(channelID) +\"/webhooks\";\r\n\t\t},\r\n\r\n\t\tWEBHOOKS: function(webhookID) {\r\n\t\t\treturn  API + \"/webhooks/\" + webhookID;\r\n\t\t},\r\n\r\n\t\tBULK_DELETE: function(channelID) {\r\n\t\t\treturn  this.CHANNEL(channelID) + \"/messages/bulk-delete\";\r\n\t\t},\r\n\r\n\t\tTYPING: function(channelID) {\r\n\t\t\treturn  this.CHANNEL(channelID) + \"/typing\";\r\n\t\t}\r\n\r\n\t};\r\n})();\r\n\r\n/* Payloads */\r\n(function() {\r\n\tPayloads = {\r\n\t\tIDENTIFY: function(client) {\r\n\t\t\treturn {\r\n\t\t\t\top: 2,\r\n\t\t\t\td: {\r\n\t\t\t\t\ttoken: client.internals.token,\r\n\t\t\t\t\tv: GATEWAY_VERSION,\r\n\t\t\t\t\tcompress: isNode && !!Zlib.inflateSync,\r\n\t\t\t\t\tlarge_threshold: LARGE_THRESHOLD,\r\n\t\t\t\t\tproperties: {\r\n\t\t\t\t\t\t$os: isNode ? require('os').platform() : navigator.platform,\r\n\t\t\t\t\t\t$browser:\"discord.io\",\r\n\t\t\t\t\t\t$device:\"discord.io\",\r\n\t\t\t\t\t\t$referrer:\"\",\r\n\t\t\t\t\t\t$referring_domain:\"\"\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\tRESUME: function(client) {\r\n\t\t\treturn {\r\n\t\t\t\top: 6,\r\n\t\t\t\td: {\r\n\t\t\t\t\tseq: client.internals.s,\r\n\t\t\t\t\ttoken: client.internals.token,\r\n\t\t\t\t\tsession_id: client.internals.sessionID\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\tHEARTBEAT: function(client) {\r\n\t\t\treturn {op: 1, d: client.internals.sequence};\r\n\t\t},\r\n\t\tALL_USERS: function(client) {\r\n\t\t\treturn {op: 12, d: Object.keys(client.servers)};\r\n\t\t},\r\n\t\tSTATUS: function(input) {\r\n\t\t\treturn {\r\n\t\t\t\top: 3,\r\n\t\t\t\td: {\r\n\t\t\t\t\tidle_since: input.idle_since || null,\r\n\t\t\t\t\tgame: type(input.game) === 'object' ?\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tname: input.game.name ? String(input.game.name) : null,\r\n\t\t\t\t\t\t\ttype: input.game.type ? Number(input.game.type) : null,\r\n\t\t\t\t\t\t\turl: input.game.url ? String(input.game.url) : null\r\n\t\t\t\t\t\t} :\r\n\t\t\t\t\t\tnull\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\tUPDATE_VOICE: function(serverID, channelID) {\r\n\t\t\treturn {\r\n\t\t\t\top: 4,\r\n\t\t\t\td: {\r\n\t\t\t\t\tguild_id: serverID,\r\n\t\t\t\t\tchannel_id: channelID,\r\n\t\t\t\t\tself_mute: false,\r\n\t\t\t\t\tself_deaf: false\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\tOFFLINE_USERS: function(array) {\r\n\t\t\treturn {\r\n\t\t\t\top: 8,\r\n\t\t\t\td: {\r\n\t\t\t\t\tguild_id: array.splice(0, 50),\r\n\t\t\t\t\tquery: \"\",\r\n\t\t\t\t\tlimit: 0\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\tVOICE_SPEAK: function(v) {\r\n\t\t\treturn {op:5, d:{ speaking: !!v, delay: 0 }};\r\n\t\t},\r\n\t\tVOICE_IDENTIFY: function(clientID, voiceSession) {\r\n\t\t\treturn {\r\n\t\t\t\top: 0,\r\n\t\t\t\td: {\r\n\t\t\t\t\tserver_id: voiceSession.serverID,\r\n\t\t\t\t\tuser_id: clientID,\r\n\t\t\t\t\tsession_id: voiceSession.session,\r\n\t\t\t\t\ttoken: voiceSession.token\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\tVOICE_DISCOVERY: function(ip, port, mode) {\r\n\t\t\treturn {\r\n\t\t\t\top:1,\r\n\t\t\t\td:{\r\n\t\t\t\t\tprotocol:\"udp\",\r\n\t\t\t\t\tdata:{\r\n\t\t\t\t\t\taddress: ip,\r\n\t\t\t\t\t\tport: Number(port),\r\n\t\t\t\t\t\tmode: mode\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n})();\r\n\r\n})(typeof exports === 'undefined'? this.Discord = {} : exports);\r\n"}